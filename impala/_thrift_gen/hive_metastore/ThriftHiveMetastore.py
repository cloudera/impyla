#
# Autogenerated by Thrift Compiler (0.10.0)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TFrozenDict, TException, TApplicationException
from thrift.protocol.TProtocol import TProtocolException
import sys
import impala._thrift_gen.fb303.FacebookService
import logging
from .ttypes import *
from thrift.Thrift import TProcessor
from thrift.transport import TTransport


class Iface(impala._thrift_gen.fb303.FacebookService.Iface):
    """
    This interface is live.
    """
    def getMetaConf(self, key):
        """
        Parameters:
         - key
        """
        pass

    def setMetaConf(self, key, value):
        """
        Parameters:
         - key
         - value
        """
        pass

    def create_database(self, database):
        """
        Parameters:
         - database
        """
        pass

    def get_database(self, name):
        """
        Parameters:
         - name
        """
        pass

    def drop_database(self, name, deleteData, cascade):
        """
        Parameters:
         - name
         - deleteData
         - cascade
        """
        pass

    def get_databases(self, pattern):
        """
        Parameters:
         - pattern
        """
        pass

    def get_all_databases(self):
        pass

    def alter_database(self, dbname, db):
        """
        Parameters:
         - dbname
         - db
        """
        pass

    def get_type(self, name):
        """
        Parameters:
         - name
        """
        pass

    def create_type(self, type):
        """
        Parameters:
         - type
        """
        pass

    def drop_type(self, type):
        """
        Parameters:
         - type
        """
        pass

    def get_type_all(self, name):
        """
        Parameters:
         - name
        """
        pass

    def get_fields(self, db_name, table_name):
        """
        Parameters:
         - db_name
         - table_name
        """
        pass

    def get_fields_with_environment_context(self, db_name, table_name, environment_context):
        """
        Parameters:
         - db_name
         - table_name
         - environment_context
        """
        pass

    def get_schema(self, db_name, table_name):
        """
        Parameters:
         - db_name
         - table_name
        """
        pass

    def get_schema_with_environment_context(self, db_name, table_name, environment_context):
        """
        Parameters:
         - db_name
         - table_name
         - environment_context
        """
        pass

    def create_table(self, tbl):
        """
        Parameters:
         - tbl
        """
        pass

    def create_table_with_environment_context(self, tbl, environment_context):
        """
        Parameters:
         - tbl
         - environment_context
        """
        pass

    def drop_table(self, dbname, name, deleteData):
        """
        Parameters:
         - dbname
         - name
         - deleteData
        """
        pass

    def drop_table_with_environment_context(self, dbname, name, deleteData, environment_context):
        """
        Parameters:
         - dbname
         - name
         - deleteData
         - environment_context
        """
        pass

    def get_tables(self, db_name, pattern):
        """
        Parameters:
         - db_name
         - pattern
        """
        pass

    def get_table_meta(self, db_patterns, tbl_patterns, tbl_types):
        """
        Parameters:
         - db_patterns
         - tbl_patterns
         - tbl_types
        """
        pass

    def get_all_tables(self, db_name):
        """
        Parameters:
         - db_name
        """
        pass

    def get_table(self, dbname, tbl_name):
        """
        Parameters:
         - dbname
         - tbl_name
        """
        pass

    def get_table_objects_by_name(self, dbname, tbl_names):
        """
        Parameters:
         - dbname
         - tbl_names
        """
        pass

    def get_table_names_by_filter(self, dbname, filter, max_tables):
        """
        Parameters:
         - dbname
         - filter
         - max_tables
        """
        pass

    def alter_table(self, dbname, tbl_name, new_tbl):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl
        """
        pass

    def alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl
         - environment_context
        """
        pass

    def alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl
         - cascade
        """
        pass

    def add_partition(self, new_part):
        """
        Parameters:
         - new_part
        """
        pass

    def add_partition_with_environment_context(self, new_part, environment_context):
        """
        Parameters:
         - new_part
         - environment_context
        """
        pass

    def add_partitions(self, new_parts):
        """
        Parameters:
         - new_parts
        """
        pass

    def add_partitions_pspec(self, new_parts):
        """
        Parameters:
         - new_parts
        """
        pass

    def append_partition(self, db_name, tbl_name, part_vals):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
        """
        pass

    def add_partitions_req(self, request):
        """
        Parameters:
         - request
        """
        pass

    def append_partition_with_environment_context(self, db_name, tbl_name, part_vals, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - environment_context
        """
        pass

    def append_partition_by_name(self, db_name, tbl_name, part_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
        """
        pass

    def append_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - environment_context
        """
        pass

    def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - deleteData
        """
        pass

    def drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - deleteData
         - environment_context
        """
        pass

    def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - deleteData
        """
        pass

    def drop_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, deleteData, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - deleteData
         - environment_context
        """
        pass

    def drop_partitions_req(self, req):
        """
        Parameters:
         - req
        """
        pass

    def get_partition(self, db_name, tbl_name, part_vals):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
        """
        pass

    def exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        """
        Parameters:
         - partitionSpecs
         - source_db
         - source_table_name
         - dest_db
         - dest_table_name
        """
        pass

    def exchange_partitions(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        """
        Parameters:
         - partitionSpecs
         - source_db
         - source_table_name
         - dest_db
         - dest_table_name
        """
        pass

    def get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - user_name
         - group_names
        """
        pass

    def get_partition_by_name(self, db_name, tbl_name, part_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
        """
        pass

    def get_partitions(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts
        """
        pass

    def get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts
         - user_name
         - group_names
        """
        pass

    def get_partitions_pspec(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts
        """
        pass

    def get_partition_names(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts
        """
        pass

    def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts
        """
        pass

    def get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts
         - user_name
         - group_names
        """
        pass

    def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts
        """
        pass

    def get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter
         - max_parts
        """
        pass

    def get_part_specs_by_filter(self, db_name, tbl_name, filter, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter
         - max_parts
        """
        pass

    def get_partitions_by_expr(self, req):
        """
        Parameters:
         - req
        """
        pass

    def get_partitions_by_names(self, db_name, tbl_name, names):
        """
        Parameters:
         - db_name
         - tbl_name
         - names
        """
        pass

    def alter_partition(self, db_name, tbl_name, new_part):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_part
        """
        pass

    def alter_partitions(self, db_name, tbl_name, new_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_parts
        """
        pass

    def alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_part
         - environment_context
        """
        pass

    def rename_partition(self, db_name, tbl_name, part_vals, new_part):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - new_part
        """
        pass

    def partition_name_has_valid_characters(self, part_vals, throw_exception):
        """
        Parameters:
         - part_vals
         - throw_exception
        """
        pass

    def get_config_value(self, name, defaultValue):
        """
        Parameters:
         - name
         - defaultValue
        """
        pass

    def partition_name_to_vals(self, part_name):
        """
        Parameters:
         - part_name
        """
        pass

    def partition_name_to_spec(self, part_name):
        """
        Parameters:
         - part_name
        """
        pass

    def markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - eventType
        """
        pass

    def isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - eventType
        """
        pass

    def add_index(self, new_index, index_table):
        """
        Parameters:
         - new_index
         - index_table
        """
        pass

    def alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
        """
        Parameters:
         - dbname
         - base_tbl_name
         - idx_name
         - new_idx
        """
        pass

    def drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - index_name
         - deleteData
        """
        pass

    def get_index_by_name(self, db_name, tbl_name, index_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - index_name
        """
        pass

    def get_indexes(self, db_name, tbl_name, max_indexes):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_indexes
        """
        pass

    def get_index_names(self, db_name, tbl_name, max_indexes):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_indexes
        """
        pass

    def update_table_column_statistics(self, stats_obj):
        """
        Parameters:
         - stats_obj
        """
        pass

    def update_partition_column_statistics(self, stats_obj):
        """
        Parameters:
         - stats_obj
        """
        pass

    def get_table_column_statistics(self, db_name, tbl_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - col_name
        """
        pass

    def get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - col_name
        """
        pass

    def get_table_statistics_req(self, request):
        """
        Parameters:
         - request
        """
        pass

    def get_partitions_statistics_req(self, request):
        """
        Parameters:
         - request
        """
        pass

    def get_aggr_stats_for(self, request):
        """
        Parameters:
         - request
        """
        pass

    def set_aggr_stats_for(self, request):
        """
        Parameters:
         - request
        """
        pass

    def delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - col_name
        """
        pass

    def delete_table_column_statistics(self, db_name, tbl_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - col_name
        """
        pass

    def create_function(self, func):
        """
        Parameters:
         - func
        """
        pass

    def drop_function(self, dbName, funcName):
        """
        Parameters:
         - dbName
         - funcName
        """
        pass

    def alter_function(self, dbName, funcName, newFunc):
        """
        Parameters:
         - dbName
         - funcName
         - newFunc
        """
        pass

    def get_functions(self, dbName, pattern):
        """
        Parameters:
         - dbName
         - pattern
        """
        pass

    def get_function(self, dbName, funcName):
        """
        Parameters:
         - dbName
         - funcName
        """
        pass

    def get_all_functions(self):
        pass

    def create_role(self, role):
        """
        Parameters:
         - role
        """
        pass

    def drop_role(self, role_name):
        """
        Parameters:
         - role_name
        """
        pass

    def get_role_names(self):
        pass

    def grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
        """
        Parameters:
         - role_name
         - principal_name
         - principal_type
         - grantor
         - grantorType
         - grant_option
        """
        pass

    def revoke_role(self, role_name, principal_name, principal_type):
        """
        Parameters:
         - role_name
         - principal_name
         - principal_type
        """
        pass

    def list_roles(self, principal_name, principal_type):
        """
        Parameters:
         - principal_name
         - principal_type
        """
        pass

    def grant_revoke_role(self, request):
        """
        Parameters:
         - request
        """
        pass

    def get_principals_in_role(self, request):
        """
        Parameters:
         - request
        """
        pass

    def get_role_grants_for_principal(self, request):
        """
        Parameters:
         - request
        """
        pass

    def get_privilege_set(self, hiveObject, user_name, group_names):
        """
        Parameters:
         - hiveObject
         - user_name
         - group_names
        """
        pass

    def list_privileges(self, principal_name, principal_type, hiveObject):
        """
        Parameters:
         - principal_name
         - principal_type
         - hiveObject
        """
        pass

    def grant_privileges(self, privileges):
        """
        Parameters:
         - privileges
        """
        pass

    def revoke_privileges(self, privileges):
        """
        Parameters:
         - privileges
        """
        pass

    def grant_revoke_privileges(self, request):
        """
        Parameters:
         - request
        """
        pass

    def set_ugi(self, user_name, group_names):
        """
        Parameters:
         - user_name
         - group_names
        """
        pass

    def get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
        """
        Parameters:
         - token_owner
         - renewer_kerberos_principal_name
        """
        pass

    def renew_delegation_token(self, token_str_form):
        """
        Parameters:
         - token_str_form
        """
        pass

    def cancel_delegation_token(self, token_str_form):
        """
        Parameters:
         - token_str_form
        """
        pass

    def get_open_txns(self):
        pass

    def get_open_txns_info(self):
        pass

    def open_txns(self, rqst):
        """
        Parameters:
         - rqst
        """
        pass

    def abort_txn(self, rqst):
        """
        Parameters:
         - rqst
        """
        pass

    def commit_txn(self, rqst):
        """
        Parameters:
         - rqst
        """
        pass

    def lock(self, rqst):
        """
        Parameters:
         - rqst
        """
        pass

    def check_lock(self, rqst):
        """
        Parameters:
         - rqst
        """
        pass

    def unlock(self, rqst):
        """
        Parameters:
         - rqst
        """
        pass

    def show_locks(self, rqst):
        """
        Parameters:
         - rqst
        """
        pass

    def heartbeat(self, ids):
        """
        Parameters:
         - ids
        """
        pass

    def heartbeat_txn_range(self, txns):
        """
        Parameters:
         - txns
        """
        pass

    def compact(self, rqst):
        """
        Parameters:
         - rqst
        """
        pass

    def show_compact(self, rqst):
        """
        Parameters:
         - rqst
        """
        pass

    def get_next_notification(self, rqst):
        """
        Parameters:
         - rqst
        """
        pass

    def get_current_notificationEventId(self):
        pass

    def fire_listener_event(self, rqst):
        """
        Parameters:
         - rqst
        """
        pass


class Client(impala._thrift_gen.fb303.FacebookService.Client, Iface):
    """
    This interface is live.
    """
    def __init__(self, iprot, oprot=None):
        impala._thrift_gen.fb303.FacebookService.Client.__init__(self, iprot, oprot)

    def getMetaConf(self, key):
        """
        Parameters:
         - key
        """
        self.send_getMetaConf(key)
        return self.recv_getMetaConf()

    def send_getMetaConf(self, key):
        self._oprot.writeMessageBegin('getMetaConf', TMessageType.CALL, self._seqid)
        args = getMetaConf_args()
        args.key = key
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_getMetaConf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = getMetaConf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "getMetaConf failed: unknown result")

    def setMetaConf(self, key, value):
        """
        Parameters:
         - key
         - value
        """
        self.send_setMetaConf(key, value)
        self.recv_setMetaConf()

    def send_setMetaConf(self, key, value):
        self._oprot.writeMessageBegin('setMetaConf', TMessageType.CALL, self._seqid)
        args = setMetaConf_args()
        args.key = key
        args.value = value
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_setMetaConf(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = setMetaConf_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def create_database(self, database):
        """
        Parameters:
         - database
        """
        self.send_create_database(database)
        self.recv_create_database()

    def send_create_database(self, database):
        self._oprot.writeMessageBegin('create_database', TMessageType.CALL, self._seqid)
        args = create_database_args()
        args.database = database
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def get_database(self, name):
        """
        Parameters:
         - name
        """
        self.send_get_database(name)
        return self.recv_get_database()

    def send_get_database(self, name):
        self._oprot.writeMessageBegin('get_database', TMessageType.CALL, self._seqid)
        args = get_database_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_database failed: unknown result")

    def drop_database(self, name, deleteData, cascade):
        """
        Parameters:
         - name
         - deleteData
         - cascade
        """
        self.send_drop_database(name, deleteData, cascade)
        self.recv_drop_database()

    def send_drop_database(self, name, deleteData, cascade):
        self._oprot.writeMessageBegin('drop_database', TMessageType.CALL, self._seqid)
        args = drop_database_args()
        args.name = name
        args.deleteData = deleteData
        args.cascade = cascade
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def get_databases(self, pattern):
        """
        Parameters:
         - pattern
        """
        self.send_get_databases(pattern)
        return self.recv_get_databases()

    def send_get_databases(self, pattern):
        self._oprot.writeMessageBegin('get_databases', TMessageType.CALL, self._seqid)
        args = get_databases_args()
        args.pattern = pattern
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_databases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_databases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_databases failed: unknown result")

    def get_all_databases(self):
        self.send_get_all_databases()
        return self.recv_get_all_databases()

    def send_get_all_databases(self):
        self._oprot.writeMessageBegin('get_all_databases', TMessageType.CALL, self._seqid)
        args = get_all_databases_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_databases(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_databases_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_databases failed: unknown result")

    def alter_database(self, dbname, db):
        """
        Parameters:
         - dbname
         - db
        """
        self.send_alter_database(dbname, db)
        self.recv_alter_database()

    def send_alter_database(self, dbname, db):
        self._oprot.writeMessageBegin('alter_database', TMessageType.CALL, self._seqid)
        args = alter_database_args()
        args.dbname = dbname
        args.db = db
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_database(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_database_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def get_type(self, name):
        """
        Parameters:
         - name
        """
        self.send_get_type(name)
        return self.recv_get_type()

    def send_get_type(self, name):
        self._oprot.writeMessageBegin('get_type', TMessageType.CALL, self._seqid)
        args = get_type_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type failed: unknown result")

    def create_type(self, type):
        """
        Parameters:
         - type
        """
        self.send_create_type(type)
        return self.recv_create_type()

    def send_create_type(self, type):
        self._oprot.writeMessageBegin('create_type', TMessageType.CALL, self._seqid)
        args = create_type_args()
        args.type = type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_type failed: unknown result")

    def drop_type(self, type):
        """
        Parameters:
         - type
        """
        self.send_drop_type(type)
        return self.recv_drop_type()

    def send_drop_type(self, type):
        self._oprot.writeMessageBegin('drop_type', TMessageType.CALL, self._seqid)
        args = drop_type_args()
        args.type = type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_type(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_type_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_type failed: unknown result")

    def get_type_all(self, name):
        """
        Parameters:
         - name
        """
        self.send_get_type_all(name)
        return self.recv_get_type_all()

    def send_get_type_all(self, name):
        self._oprot.writeMessageBegin('get_type_all', TMessageType.CALL, self._seqid)
        args = get_type_all_args()
        args.name = name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_type_all(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_type_all_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_type_all failed: unknown result")

    def get_fields(self, db_name, table_name):
        """
        Parameters:
         - db_name
         - table_name
        """
        self.send_get_fields(db_name, table_name)
        return self.recv_get_fields()

    def send_get_fields(self, db_name, table_name):
        self._oprot.writeMessageBegin('get_fields', TMessageType.CALL, self._seqid)
        args = get_fields_args()
        args.db_name = db_name
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_fields(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_fields_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fields failed: unknown result")

    def get_fields_with_environment_context(self, db_name, table_name, environment_context):
        """
        Parameters:
         - db_name
         - table_name
         - environment_context
        """
        self.send_get_fields_with_environment_context(db_name, table_name, environment_context)
        return self.recv_get_fields_with_environment_context()

    def send_get_fields_with_environment_context(self, db_name, table_name, environment_context):
        self._oprot.writeMessageBegin('get_fields_with_environment_context', TMessageType.CALL, self._seqid)
        args = get_fields_with_environment_context_args()
        args.db_name = db_name
        args.table_name = table_name
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_fields_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_fields_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_fields_with_environment_context failed: unknown result")

    def get_schema(self, db_name, table_name):
        """
        Parameters:
         - db_name
         - table_name
        """
        self.send_get_schema(db_name, table_name)
        return self.recv_get_schema()

    def send_get_schema(self, db_name, table_name):
        self._oprot.writeMessageBegin('get_schema', TMessageType.CALL, self._seqid)
        args = get_schema_args()
        args.db_name = db_name
        args.table_name = table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schema(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schema_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema failed: unknown result")

    def get_schema_with_environment_context(self, db_name, table_name, environment_context):
        """
        Parameters:
         - db_name
         - table_name
         - environment_context
        """
        self.send_get_schema_with_environment_context(db_name, table_name, environment_context)
        return self.recv_get_schema_with_environment_context()

    def send_get_schema_with_environment_context(self, db_name, table_name, environment_context):
        self._oprot.writeMessageBegin('get_schema_with_environment_context', TMessageType.CALL, self._seqid)
        args = get_schema_with_environment_context_args()
        args.db_name = db_name
        args.table_name = table_name
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_schema_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_schema_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_schema_with_environment_context failed: unknown result")

    def create_table(self, tbl):
        """
        Parameters:
         - tbl
        """
        self.send_create_table(tbl)
        self.recv_create_table()

    def send_create_table(self, tbl):
        self._oprot.writeMessageBegin('create_table', TMessageType.CALL, self._seqid)
        args = create_table_args()
        args.tbl = tbl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        return

    def create_table_with_environment_context(self, tbl, environment_context):
        """
        Parameters:
         - tbl
         - environment_context
        """
        self.send_create_table_with_environment_context(tbl, environment_context)
        self.recv_create_table_with_environment_context()

    def send_create_table_with_environment_context(self, tbl, environment_context):
        self._oprot.writeMessageBegin('create_table_with_environment_context', TMessageType.CALL, self._seqid)
        args = create_table_with_environment_context_args()
        args.tbl = tbl
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_table_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_table_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        return

    def drop_table(self, dbname, name, deleteData):
        """
        Parameters:
         - dbname
         - name
         - deleteData
        """
        self.send_drop_table(dbname, name, deleteData)
        self.recv_drop_table()

    def send_drop_table(self, dbname, name, deleteData):
        self._oprot.writeMessageBegin('drop_table', TMessageType.CALL, self._seqid)
        args = drop_table_args()
        args.dbname = dbname
        args.name = name
        args.deleteData = deleteData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o3 is not None:
            raise result.o3
        return

    def drop_table_with_environment_context(self, dbname, name, deleteData, environment_context):
        """
        Parameters:
         - dbname
         - name
         - deleteData
         - environment_context
        """
        self.send_drop_table_with_environment_context(dbname, name, deleteData, environment_context)
        self.recv_drop_table_with_environment_context()

    def send_drop_table_with_environment_context(self, dbname, name, deleteData, environment_context):
        self._oprot.writeMessageBegin('drop_table_with_environment_context', TMessageType.CALL, self._seqid)
        args = drop_table_with_environment_context_args()
        args.dbname = dbname
        args.name = name
        args.deleteData = deleteData
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_table_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_table_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o3 is not None:
            raise result.o3
        return

    def get_tables(self, db_name, pattern):
        """
        Parameters:
         - db_name
         - pattern
        """
        self.send_get_tables(db_name, pattern)
        return self.recv_get_tables()

    def send_get_tables(self, db_name, pattern):
        self._oprot.writeMessageBegin('get_tables', TMessageType.CALL, self._seqid)
        args = get_tables_args()
        args.db_name = db_name
        args.pattern = pattern
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_tables(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_tables_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_tables failed: unknown result")

    def get_table_meta(self, db_patterns, tbl_patterns, tbl_types):
        """
        Parameters:
         - db_patterns
         - tbl_patterns
         - tbl_types
        """
        self.send_get_table_meta(db_patterns, tbl_patterns, tbl_types)
        return self.recv_get_table_meta()

    def send_get_table_meta(self, db_patterns, tbl_patterns, tbl_types):
        self._oprot.writeMessageBegin('get_table_meta', TMessageType.CALL, self._seqid)
        args = get_table_meta_args()
        args.db_patterns = db_patterns
        args.tbl_patterns = tbl_patterns
        args.tbl_types = tbl_types
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_meta(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_meta_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_meta failed: unknown result")

    def get_all_tables(self, db_name):
        """
        Parameters:
         - db_name
        """
        self.send_get_all_tables(db_name)
        return self.recv_get_all_tables()

    def send_get_all_tables(self, db_name):
        self._oprot.writeMessageBegin('get_all_tables', TMessageType.CALL, self._seqid)
        args = get_all_tables_args()
        args.db_name = db_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_tables(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_tables_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_tables failed: unknown result")

    def get_table(self, dbname, tbl_name):
        """
        Parameters:
         - dbname
         - tbl_name
        """
        self.send_get_table(dbname, tbl_name)
        return self.recv_get_table()

    def send_get_table(self, dbname, tbl_name):
        self._oprot.writeMessageBegin('get_table', TMessageType.CALL, self._seqid)
        args = get_table_args()
        args.dbname = dbname
        args.tbl_name = tbl_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table failed: unknown result")

    def get_table_objects_by_name(self, dbname, tbl_names):
        """
        Parameters:
         - dbname
         - tbl_names
        """
        self.send_get_table_objects_by_name(dbname, tbl_names)
        return self.recv_get_table_objects_by_name()

    def send_get_table_objects_by_name(self, dbname, tbl_names):
        self._oprot.writeMessageBegin('get_table_objects_by_name', TMessageType.CALL, self._seqid)
        args = get_table_objects_by_name_args()
        args.dbname = dbname
        args.tbl_names = tbl_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_objects_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_objects_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_objects_by_name failed: unknown result")

    def get_table_names_by_filter(self, dbname, filter, max_tables):
        """
        Parameters:
         - dbname
         - filter
         - max_tables
        """
        self.send_get_table_names_by_filter(dbname, filter, max_tables)
        return self.recv_get_table_names_by_filter()

    def send_get_table_names_by_filter(self, dbname, filter, max_tables):
        self._oprot.writeMessageBegin('get_table_names_by_filter', TMessageType.CALL, self._seqid)
        args = get_table_names_by_filter_args()
        args.dbname = dbname
        args.filter = filter
        args.max_tables = max_tables
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_names_by_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_names_by_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_names_by_filter failed: unknown result")

    def alter_table(self, dbname, tbl_name, new_tbl):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl
        """
        self.send_alter_table(dbname, tbl_name, new_tbl)
        self.recv_alter_table()

    def send_alter_table(self, dbname, tbl_name, new_tbl):
        self._oprot.writeMessageBegin('alter_table', TMessageType.CALL, self._seqid)
        args = alter_table_args()
        args.dbname = dbname
        args.tbl_name = tbl_name
        args.new_tbl = new_tbl
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_table(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_table_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl
         - environment_context
        """
        self.send_alter_table_with_environment_context(dbname, tbl_name, new_tbl, environment_context)
        self.recv_alter_table_with_environment_context()

    def send_alter_table_with_environment_context(self, dbname, tbl_name, new_tbl, environment_context):
        self._oprot.writeMessageBegin('alter_table_with_environment_context', TMessageType.CALL, self._seqid)
        args = alter_table_with_environment_context_args()
        args.dbname = dbname
        args.tbl_name = tbl_name
        args.new_tbl = new_tbl
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_table_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_table_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):
        """
        Parameters:
         - dbname
         - tbl_name
         - new_tbl
         - cascade
        """
        self.send_alter_table_with_cascade(dbname, tbl_name, new_tbl, cascade)
        self.recv_alter_table_with_cascade()

    def send_alter_table_with_cascade(self, dbname, tbl_name, new_tbl, cascade):
        self._oprot.writeMessageBegin('alter_table_with_cascade', TMessageType.CALL, self._seqid)
        args = alter_table_with_cascade_args()
        args.dbname = dbname
        args.tbl_name = tbl_name
        args.new_tbl = new_tbl
        args.cascade = cascade
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_table_with_cascade(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_table_with_cascade_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def add_partition(self, new_part):
        """
        Parameters:
         - new_part
        """
        self.send_add_partition(new_part)
        return self.recv_add_partition()

    def send_add_partition(self, new_part):
        self._oprot.writeMessageBegin('add_partition', TMessageType.CALL, self._seqid)
        args = add_partition_args()
        args.new_part = new_part
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition failed: unknown result")

    def add_partition_with_environment_context(self, new_part, environment_context):
        """
        Parameters:
         - new_part
         - environment_context
        """
        self.send_add_partition_with_environment_context(new_part, environment_context)
        return self.recv_add_partition_with_environment_context()

    def send_add_partition_with_environment_context(self, new_part, environment_context):
        self._oprot.writeMessageBegin('add_partition_with_environment_context', TMessageType.CALL, self._seqid)
        args = add_partition_with_environment_context_args()
        args.new_part = new_part
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_partition_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_partition_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partition_with_environment_context failed: unknown result")

    def add_partitions(self, new_parts):
        """
        Parameters:
         - new_parts
        """
        self.send_add_partitions(new_parts)
        return self.recv_add_partitions()

    def send_add_partitions(self, new_parts):
        self._oprot.writeMessageBegin('add_partitions', TMessageType.CALL, self._seqid)
        args = add_partitions_args()
        args.new_parts = new_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_partitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_partitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions failed: unknown result")

    def add_partitions_pspec(self, new_parts):
        """
        Parameters:
         - new_parts
        """
        self.send_add_partitions_pspec(new_parts)
        return self.recv_add_partitions_pspec()

    def send_add_partitions_pspec(self, new_parts):
        self._oprot.writeMessageBegin('add_partitions_pspec', TMessageType.CALL, self._seqid)
        args = add_partitions_pspec_args()
        args.new_parts = new_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_partitions_pspec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_partitions_pspec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions_pspec failed: unknown result")

    def append_partition(self, db_name, tbl_name, part_vals):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
        """
        self.send_append_partition(db_name, tbl_name, part_vals)
        return self.recv_append_partition()

    def send_append_partition(self, db_name, tbl_name, part_vals):
        self._oprot.writeMessageBegin('append_partition', TMessageType.CALL, self._seqid)
        args = append_partition_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_append_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = append_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition failed: unknown result")

    def add_partitions_req(self, request):
        """
        Parameters:
         - request
        """
        self.send_add_partitions_req(request)
        return self.recv_add_partitions_req()

    def send_add_partitions_req(self, request):
        self._oprot.writeMessageBegin('add_partitions_req', TMessageType.CALL, self._seqid)
        args = add_partitions_req_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_partitions_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_partitions_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_partitions_req failed: unknown result")

    def append_partition_with_environment_context(self, db_name, tbl_name, part_vals, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - environment_context
        """
        self.send_append_partition_with_environment_context(db_name, tbl_name, part_vals, environment_context)
        return self.recv_append_partition_with_environment_context()

    def send_append_partition_with_environment_context(self, db_name, tbl_name, part_vals, environment_context):
        self._oprot.writeMessageBegin('append_partition_with_environment_context', TMessageType.CALL, self._seqid)
        args = append_partition_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_append_partition_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = append_partition_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_with_environment_context failed: unknown result")

    def append_partition_by_name(self, db_name, tbl_name, part_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
        """
        self.send_append_partition_by_name(db_name, tbl_name, part_name)
        return self.recv_append_partition_by_name()

    def send_append_partition_by_name(self, db_name, tbl_name, part_name):
        self._oprot.writeMessageBegin('append_partition_by_name', TMessageType.CALL, self._seqid)
        args = append_partition_by_name_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_append_partition_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = append_partition_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_by_name failed: unknown result")

    def append_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - environment_context
        """
        self.send_append_partition_by_name_with_environment_context(db_name, tbl_name, part_name, environment_context)
        return self.recv_append_partition_by_name_with_environment_context()

    def send_append_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, environment_context):
        self._oprot.writeMessageBegin('append_partition_by_name_with_environment_context', TMessageType.CALL, self._seqid)
        args = append_partition_by_name_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_append_partition_by_name_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = append_partition_by_name_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "append_partition_by_name_with_environment_context failed: unknown result")

    def drop_partition(self, db_name, tbl_name, part_vals, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - deleteData
        """
        self.send_drop_partition(db_name, tbl_name, part_vals, deleteData)
        return self.recv_drop_partition()

    def send_drop_partition(self, db_name, tbl_name, part_vals, deleteData):
        self._oprot.writeMessageBegin('drop_partition', TMessageType.CALL, self._seqid)
        args = drop_partition_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.deleteData = deleteData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition failed: unknown result")

    def drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - deleteData
         - environment_context
        """
        self.send_drop_partition_with_environment_context(db_name, tbl_name, part_vals, deleteData, environment_context)
        return self.recv_drop_partition_with_environment_context()

    def send_drop_partition_with_environment_context(self, db_name, tbl_name, part_vals, deleteData, environment_context):
        self._oprot.writeMessageBegin('drop_partition_with_environment_context', TMessageType.CALL, self._seqid)
        args = drop_partition_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.deleteData = deleteData
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_partition_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_partition_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_with_environment_context failed: unknown result")

    def drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - deleteData
        """
        self.send_drop_partition_by_name(db_name, tbl_name, part_name, deleteData)
        return self.recv_drop_partition_by_name()

    def send_drop_partition_by_name(self, db_name, tbl_name, part_name, deleteData):
        self._oprot.writeMessageBegin('drop_partition_by_name', TMessageType.CALL, self._seqid)
        args = drop_partition_by_name_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.deleteData = deleteData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_partition_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_partition_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_by_name failed: unknown result")

    def drop_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, deleteData, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - deleteData
         - environment_context
        """
        self.send_drop_partition_by_name_with_environment_context(db_name, tbl_name, part_name, deleteData, environment_context)
        return self.recv_drop_partition_by_name_with_environment_context()

    def send_drop_partition_by_name_with_environment_context(self, db_name, tbl_name, part_name, deleteData, environment_context):
        self._oprot.writeMessageBegin('drop_partition_by_name_with_environment_context', TMessageType.CALL, self._seqid)
        args = drop_partition_by_name_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.deleteData = deleteData
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_partition_by_name_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_partition_by_name_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partition_by_name_with_environment_context failed: unknown result")

    def drop_partitions_req(self, req):
        """
        Parameters:
         - req
        """
        self.send_drop_partitions_req(req)
        return self.recv_drop_partitions_req()

    def send_drop_partitions_req(self, req):
        self._oprot.writeMessageBegin('drop_partitions_req', TMessageType.CALL, self._seqid)
        args = drop_partitions_req_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_partitions_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_partitions_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_partitions_req failed: unknown result")

    def get_partition(self, db_name, tbl_name, part_vals):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
        """
        self.send_get_partition(db_name, tbl_name, part_vals)
        return self.recv_get_partition()

    def send_get_partition(self, db_name, tbl_name, part_vals):
        self._oprot.writeMessageBegin('get_partition', TMessageType.CALL, self._seqid)
        args = get_partition_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition failed: unknown result")

    def exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        """
        Parameters:
         - partitionSpecs
         - source_db
         - source_table_name
         - dest_db
         - dest_table_name
        """
        self.send_exchange_partition(partitionSpecs, source_db, source_table_name, dest_db, dest_table_name)
        return self.recv_exchange_partition()

    def send_exchange_partition(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        self._oprot.writeMessageBegin('exchange_partition', TMessageType.CALL, self._seqid)
        args = exchange_partition_args()
        args.partitionSpecs = partitionSpecs
        args.source_db = source_db
        args.source_table_name = source_table_name
        args.dest_db = dest_db
        args.dest_table_name = dest_table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exchange_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exchange_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "exchange_partition failed: unknown result")

    def exchange_partitions(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        """
        Parameters:
         - partitionSpecs
         - source_db
         - source_table_name
         - dest_db
         - dest_table_name
        """
        self.send_exchange_partitions(partitionSpecs, source_db, source_table_name, dest_db, dest_table_name)
        return self.recv_exchange_partitions()

    def send_exchange_partitions(self, partitionSpecs, source_db, source_table_name, dest_db, dest_table_name):
        self._oprot.writeMessageBegin('exchange_partitions', TMessageType.CALL, self._seqid)
        args = exchange_partitions_args()
        args.partitionSpecs = partitionSpecs
        args.source_db = source_db
        args.source_table_name = source_table_name
        args.dest_db = dest_db
        args.dest_table_name = dest_table_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_exchange_partitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = exchange_partitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "exchange_partitions failed: unknown result")

    def get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - user_name
         - group_names
        """
        self.send_get_partition_with_auth(db_name, tbl_name, part_vals, user_name, group_names)
        return self.recv_get_partition_with_auth()

    def send_get_partition_with_auth(self, db_name, tbl_name, part_vals, user_name, group_names):
        self._oprot.writeMessageBegin('get_partition_with_auth', TMessageType.CALL, self._seqid)
        args = get_partition_with_auth_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.user_name = user_name
        args.group_names = group_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_with_auth(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_with_auth_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_with_auth failed: unknown result")

    def get_partition_by_name(self, db_name, tbl_name, part_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
        """
        self.send_get_partition_by_name(db_name, tbl_name, part_name)
        return self.recv_get_partition_by_name()

    def send_get_partition_by_name(self, db_name, tbl_name, part_name):
        self._oprot.writeMessageBegin('get_partition_by_name', TMessageType.CALL, self._seqid)
        args = get_partition_by_name_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_by_name failed: unknown result")

    def get_partitions(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts
        """
        self.send_get_partitions(db_name, tbl_name, max_parts)
        return self.recv_get_partitions()

    def send_get_partitions(self, db_name, tbl_name, max_parts):
        self._oprot.writeMessageBegin('get_partitions', TMessageType.CALL, self._seqid)
        args = get_partitions_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions failed: unknown result")

    def get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts
         - user_name
         - group_names
        """
        self.send_get_partitions_with_auth(db_name, tbl_name, max_parts, user_name, group_names)
        return self.recv_get_partitions_with_auth()

    def send_get_partitions_with_auth(self, db_name, tbl_name, max_parts, user_name, group_names):
        self._oprot.writeMessageBegin('get_partitions_with_auth', TMessageType.CALL, self._seqid)
        args = get_partitions_with_auth_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_parts = max_parts
        args.user_name = user_name
        args.group_names = group_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_with_auth(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_with_auth_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_with_auth failed: unknown result")

    def get_partitions_pspec(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts
        """
        self.send_get_partitions_pspec(db_name, tbl_name, max_parts)
        return self.recv_get_partitions_pspec()

    def send_get_partitions_pspec(self, db_name, tbl_name, max_parts):
        self._oprot.writeMessageBegin('get_partitions_pspec', TMessageType.CALL, self._seqid)
        args = get_partitions_pspec_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_pspec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_pspec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_pspec failed: unknown result")

    def get_partition_names(self, db_name, tbl_name, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_parts
        """
        self.send_get_partition_names(db_name, tbl_name, max_parts)
        return self.recv_get_partition_names()

    def send_get_partition_names(self, db_name, tbl_name, max_parts):
        self._oprot.writeMessageBegin('get_partition_names', TMessageType.CALL, self._seqid)
        args = get_partition_names_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_names(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_names_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names failed: unknown result")

    def get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts
        """
        self.send_get_partitions_ps(db_name, tbl_name, part_vals, max_parts)
        return self.recv_get_partitions_ps()

    def send_get_partitions_ps(self, db_name, tbl_name, part_vals, max_parts):
        self._oprot.writeMessageBegin('get_partitions_ps', TMessageType.CALL, self._seqid)
        args = get_partitions_ps_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_ps(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_ps_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps failed: unknown result")

    def get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts
         - user_name
         - group_names
        """
        self.send_get_partitions_ps_with_auth(db_name, tbl_name, part_vals, max_parts, user_name, group_names)
        return self.recv_get_partitions_ps_with_auth()

    def send_get_partitions_ps_with_auth(self, db_name, tbl_name, part_vals, max_parts, user_name, group_names):
        self._oprot.writeMessageBegin('get_partitions_ps_with_auth', TMessageType.CALL, self._seqid)
        args = get_partitions_ps_with_auth_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.max_parts = max_parts
        args.user_name = user_name
        args.group_names = group_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_ps_with_auth(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_ps_with_auth_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_ps_with_auth failed: unknown result")

    def get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - max_parts
        """
        self.send_get_partition_names_ps(db_name, tbl_name, part_vals, max_parts)
        return self.recv_get_partition_names_ps()

    def send_get_partition_names_ps(self, db_name, tbl_name, part_vals, max_parts):
        self._oprot.writeMessageBegin('get_partition_names_ps', TMessageType.CALL, self._seqid)
        args = get_partition_names_ps_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_names_ps(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_names_ps_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_names_ps failed: unknown result")

    def get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter
         - max_parts
        """
        self.send_get_partitions_by_filter(db_name, tbl_name, filter, max_parts)
        return self.recv_get_partitions_by_filter()

    def send_get_partitions_by_filter(self, db_name, tbl_name, filter, max_parts):
        self._oprot.writeMessageBegin('get_partitions_by_filter', TMessageType.CALL, self._seqid)
        args = get_partitions_by_filter_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.filter = filter
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_by_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_by_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_filter failed: unknown result")

    def get_part_specs_by_filter(self, db_name, tbl_name, filter, max_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - filter
         - max_parts
        """
        self.send_get_part_specs_by_filter(db_name, tbl_name, filter, max_parts)
        return self.recv_get_part_specs_by_filter()

    def send_get_part_specs_by_filter(self, db_name, tbl_name, filter, max_parts):
        self._oprot.writeMessageBegin('get_part_specs_by_filter', TMessageType.CALL, self._seqid)
        args = get_part_specs_by_filter_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.filter = filter
        args.max_parts = max_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_part_specs_by_filter(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_part_specs_by_filter_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_part_specs_by_filter failed: unknown result")

    def get_partitions_by_expr(self, req):
        """
        Parameters:
         - req
        """
        self.send_get_partitions_by_expr(req)
        return self.recv_get_partitions_by_expr()

    def send_get_partitions_by_expr(self, req):
        self._oprot.writeMessageBegin('get_partitions_by_expr', TMessageType.CALL, self._seqid)
        args = get_partitions_by_expr_args()
        args.req = req
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_by_expr(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_by_expr_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_expr failed: unknown result")

    def get_partitions_by_names(self, db_name, tbl_name, names):
        """
        Parameters:
         - db_name
         - tbl_name
         - names
        """
        self.send_get_partitions_by_names(db_name, tbl_name, names)
        return self.recv_get_partitions_by_names()

    def send_get_partitions_by_names(self, db_name, tbl_name, names):
        self._oprot.writeMessageBegin('get_partitions_by_names', TMessageType.CALL, self._seqid)
        args = get_partitions_by_names_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.names = names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_by_names(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_by_names_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_by_names failed: unknown result")

    def alter_partition(self, db_name, tbl_name, new_part):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_part
        """
        self.send_alter_partition(db_name, tbl_name, new_part)
        self.recv_alter_partition()

    def send_alter_partition(self, db_name, tbl_name, new_part):
        self._oprot.writeMessageBegin('alter_partition', TMessageType.CALL, self._seqid)
        args = alter_partition_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.new_part = new_part
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def alter_partitions(self, db_name, tbl_name, new_parts):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_parts
        """
        self.send_alter_partitions(db_name, tbl_name, new_parts)
        self.recv_alter_partitions()

    def send_alter_partitions(self, db_name, tbl_name, new_parts):
        self._oprot.writeMessageBegin('alter_partitions', TMessageType.CALL, self._seqid)
        args = alter_partitions_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.new_parts = new_parts
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_partitions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_partitions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
        """
        Parameters:
         - db_name
         - tbl_name
         - new_part
         - environment_context
        """
        self.send_alter_partition_with_environment_context(db_name, tbl_name, new_part, environment_context)
        self.recv_alter_partition_with_environment_context()

    def send_alter_partition_with_environment_context(self, db_name, tbl_name, new_part, environment_context):
        self._oprot.writeMessageBegin('alter_partition_with_environment_context', TMessageType.CALL, self._seqid)
        args = alter_partition_with_environment_context_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.new_part = new_part
        args.environment_context = environment_context
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_partition_with_environment_context(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_partition_with_environment_context_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def rename_partition(self, db_name, tbl_name, part_vals, new_part):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - new_part
        """
        self.send_rename_partition(db_name, tbl_name, part_vals, new_part)
        self.recv_rename_partition()

    def send_rename_partition(self, db_name, tbl_name, part_vals, new_part):
        self._oprot.writeMessageBegin('rename_partition', TMessageType.CALL, self._seqid)
        args = rename_partition_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.new_part = new_part
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_rename_partition(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = rename_partition_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def partition_name_has_valid_characters(self, part_vals, throw_exception):
        """
        Parameters:
         - part_vals
         - throw_exception
        """
        self.send_partition_name_has_valid_characters(part_vals, throw_exception)
        return self.recv_partition_name_has_valid_characters()

    def send_partition_name_has_valid_characters(self, part_vals, throw_exception):
        self._oprot.writeMessageBegin('partition_name_has_valid_characters', TMessageType.CALL, self._seqid)
        args = partition_name_has_valid_characters_args()
        args.part_vals = part_vals
        args.throw_exception = throw_exception
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_partition_name_has_valid_characters(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = partition_name_has_valid_characters_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_has_valid_characters failed: unknown result")

    def get_config_value(self, name, defaultValue):
        """
        Parameters:
         - name
         - defaultValue
        """
        self.send_get_config_value(name, defaultValue)
        return self.recv_get_config_value()

    def send_get_config_value(self, name, defaultValue):
        self._oprot.writeMessageBegin('get_config_value', TMessageType.CALL, self._seqid)
        args = get_config_value_args()
        args.name = name
        args.defaultValue = defaultValue
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_config_value(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_config_value_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_config_value failed: unknown result")

    def partition_name_to_vals(self, part_name):
        """
        Parameters:
         - part_name
        """
        self.send_partition_name_to_vals(part_name)
        return self.recv_partition_name_to_vals()

    def send_partition_name_to_vals(self, part_name):
        self._oprot.writeMessageBegin('partition_name_to_vals', TMessageType.CALL, self._seqid)
        args = partition_name_to_vals_args()
        args.part_name = part_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_partition_name_to_vals(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = partition_name_to_vals_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_vals failed: unknown result")

    def partition_name_to_spec(self, part_name):
        """
        Parameters:
         - part_name
        """
        self.send_partition_name_to_spec(part_name)
        return self.recv_partition_name_to_spec()

    def send_partition_name_to_spec(self, part_name):
        self._oprot.writeMessageBegin('partition_name_to_spec', TMessageType.CALL, self._seqid)
        args = partition_name_to_spec_args()
        args.part_name = part_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_partition_name_to_spec(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = partition_name_to_spec_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "partition_name_to_spec failed: unknown result")

    def markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - eventType
        """
        self.send_markPartitionForEvent(db_name, tbl_name, part_vals, eventType)
        self.recv_markPartitionForEvent()

    def send_markPartitionForEvent(self, db_name, tbl_name, part_vals, eventType):
        self._oprot.writeMessageBegin('markPartitionForEvent', TMessageType.CALL, self._seqid)
        args = markPartitionForEvent_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.eventType = eventType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_markPartitionForEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = markPartitionForEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        if result.o5 is not None:
            raise result.o5
        if result.o6 is not None:
            raise result.o6
        return

    def isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_vals
         - eventType
        """
        self.send_isPartitionMarkedForEvent(db_name, tbl_name, part_vals, eventType)
        return self.recv_isPartitionMarkedForEvent()

    def send_isPartitionMarkedForEvent(self, db_name, tbl_name, part_vals, eventType):
        self._oprot.writeMessageBegin('isPartitionMarkedForEvent', TMessageType.CALL, self._seqid)
        args = isPartitionMarkedForEvent_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_vals = part_vals
        args.eventType = eventType
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_isPartitionMarkedForEvent(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = isPartitionMarkedForEvent_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        if result.o5 is not None:
            raise result.o5
        if result.o6 is not None:
            raise result.o6
        raise TApplicationException(TApplicationException.MISSING_RESULT, "isPartitionMarkedForEvent failed: unknown result")

    def add_index(self, new_index, index_table):
        """
        Parameters:
         - new_index
         - index_table
        """
        self.send_add_index(new_index, index_table)
        return self.recv_add_index()

    def send_add_index(self, new_index, index_table):
        self._oprot.writeMessageBegin('add_index', TMessageType.CALL, self._seqid)
        args = add_index_args()
        args.new_index = new_index
        args.index_table = index_table
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_add_index(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = add_index_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "add_index failed: unknown result")

    def alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
        """
        Parameters:
         - dbname
         - base_tbl_name
         - idx_name
         - new_idx
        """
        self.send_alter_index(dbname, base_tbl_name, idx_name, new_idx)
        self.recv_alter_index()

    def send_alter_index(self, dbname, base_tbl_name, idx_name, new_idx):
        self._oprot.writeMessageBegin('alter_index', TMessageType.CALL, self._seqid)
        args = alter_index_args()
        args.dbname = dbname
        args.base_tbl_name = base_tbl_name
        args.idx_name = idx_name
        args.new_idx = new_idx
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_index(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_index_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
        """
        Parameters:
         - db_name
         - tbl_name
         - index_name
         - deleteData
        """
        self.send_drop_index_by_name(db_name, tbl_name, index_name, deleteData)
        return self.recv_drop_index_by_name()

    def send_drop_index_by_name(self, db_name, tbl_name, index_name, deleteData):
        self._oprot.writeMessageBegin('drop_index_by_name', TMessageType.CALL, self._seqid)
        args = drop_index_by_name_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.index_name = index_name
        args.deleteData = deleteData
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_index_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_index_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_index_by_name failed: unknown result")

    def get_index_by_name(self, db_name, tbl_name, index_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - index_name
        """
        self.send_get_index_by_name(db_name, tbl_name, index_name)
        return self.recv_get_index_by_name()

    def send_get_index_by_name(self, db_name, tbl_name, index_name):
        self._oprot.writeMessageBegin('get_index_by_name', TMessageType.CALL, self._seqid)
        args = get_index_by_name_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.index_name = index_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_index_by_name(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_index_by_name_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_index_by_name failed: unknown result")

    def get_indexes(self, db_name, tbl_name, max_indexes):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_indexes
        """
        self.send_get_indexes(db_name, tbl_name, max_indexes)
        return self.recv_get_indexes()

    def send_get_indexes(self, db_name, tbl_name, max_indexes):
        self._oprot.writeMessageBegin('get_indexes', TMessageType.CALL, self._seqid)
        args = get_indexes_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_indexes = max_indexes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_indexes(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_indexes_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_indexes failed: unknown result")

    def get_index_names(self, db_name, tbl_name, max_indexes):
        """
        Parameters:
         - db_name
         - tbl_name
         - max_indexes
        """
        self.send_get_index_names(db_name, tbl_name, max_indexes)
        return self.recv_get_index_names()

    def send_get_index_names(self, db_name, tbl_name, max_indexes):
        self._oprot.writeMessageBegin('get_index_names', TMessageType.CALL, self._seqid)
        args = get_index_names_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.max_indexes = max_indexes
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_index_names(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_index_names_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_index_names failed: unknown result")

    def update_table_column_statistics(self, stats_obj):
        """
        Parameters:
         - stats_obj
        """
        self.send_update_table_column_statistics(stats_obj)
        return self.recv_update_table_column_statistics()

    def send_update_table_column_statistics(self, stats_obj):
        self._oprot.writeMessageBegin('update_table_column_statistics', TMessageType.CALL, self._seqid)
        args = update_table_column_statistics_args()
        args.stats_obj = stats_obj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_table_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_table_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "update_table_column_statistics failed: unknown result")

    def update_partition_column_statistics(self, stats_obj):
        """
        Parameters:
         - stats_obj
        """
        self.send_update_partition_column_statistics(stats_obj)
        return self.recv_update_partition_column_statistics()

    def send_update_partition_column_statistics(self, stats_obj):
        self._oprot.writeMessageBegin('update_partition_column_statistics', TMessageType.CALL, self._seqid)
        args = update_partition_column_statistics_args()
        args.stats_obj = stats_obj
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_update_partition_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = update_partition_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "update_partition_column_statistics failed: unknown result")

    def get_table_column_statistics(self, db_name, tbl_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - col_name
        """
        self.send_get_table_column_statistics(db_name, tbl_name, col_name)
        return self.recv_get_table_column_statistics()

    def send_get_table_column_statistics(self, db_name, tbl_name, col_name):
        self._oprot.writeMessageBegin('get_table_column_statistics', TMessageType.CALL, self._seqid)
        args = get_table_column_statistics_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.col_name = col_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_column_statistics failed: unknown result")

    def get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - col_name
        """
        self.send_get_partition_column_statistics(db_name, tbl_name, part_name, col_name)
        return self.recv_get_partition_column_statistics()

    def send_get_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
        self._oprot.writeMessageBegin('get_partition_column_statistics', TMessageType.CALL, self._seqid)
        args = get_partition_column_statistics_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.col_name = col_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partition_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partition_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partition_column_statistics failed: unknown result")

    def get_table_statistics_req(self, request):
        """
        Parameters:
         - request
        """
        self.send_get_table_statistics_req(request)
        return self.recv_get_table_statistics_req()

    def send_get_table_statistics_req(self, request):
        self._oprot.writeMessageBegin('get_table_statistics_req', TMessageType.CALL, self._seqid)
        args = get_table_statistics_req_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_table_statistics_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_table_statistics_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_table_statistics_req failed: unknown result")

    def get_partitions_statistics_req(self, request):
        """
        Parameters:
         - request
        """
        self.send_get_partitions_statistics_req(request)
        return self.recv_get_partitions_statistics_req()

    def send_get_partitions_statistics_req(self, request):
        self._oprot.writeMessageBegin('get_partitions_statistics_req', TMessageType.CALL, self._seqid)
        args = get_partitions_statistics_req_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_partitions_statistics_req(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_partitions_statistics_req_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_partitions_statistics_req failed: unknown result")

    def get_aggr_stats_for(self, request):
        """
        Parameters:
         - request
        """
        self.send_get_aggr_stats_for(request)
        return self.recv_get_aggr_stats_for()

    def send_get_aggr_stats_for(self, request):
        self._oprot.writeMessageBegin('get_aggr_stats_for', TMessageType.CALL, self._seqid)
        args = get_aggr_stats_for_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_aggr_stats_for(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_aggr_stats_for_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_aggr_stats_for failed: unknown result")

    def set_aggr_stats_for(self, request):
        """
        Parameters:
         - request
        """
        self.send_set_aggr_stats_for(request)
        return self.recv_set_aggr_stats_for()

    def send_set_aggr_stats_for(self, request):
        self._oprot.writeMessageBegin('set_aggr_stats_for', TMessageType.CALL, self._seqid)
        args = set_aggr_stats_for_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_aggr_stats_for(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_aggr_stats_for_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_aggr_stats_for failed: unknown result")

    def delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - part_name
         - col_name
        """
        self.send_delete_partition_column_statistics(db_name, tbl_name, part_name, col_name)
        return self.recv_delete_partition_column_statistics()

    def send_delete_partition_column_statistics(self, db_name, tbl_name, part_name, col_name):
        self._oprot.writeMessageBegin('delete_partition_column_statistics', TMessageType.CALL, self._seqid)
        args = delete_partition_column_statistics_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.part_name = part_name
        args.col_name = col_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_partition_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_partition_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_partition_column_statistics failed: unknown result")

    def delete_table_column_statistics(self, db_name, tbl_name, col_name):
        """
        Parameters:
         - db_name
         - tbl_name
         - col_name
        """
        self.send_delete_table_column_statistics(db_name, tbl_name, col_name)
        return self.recv_delete_table_column_statistics()

    def send_delete_table_column_statistics(self, db_name, tbl_name, col_name):
        self._oprot.writeMessageBegin('delete_table_column_statistics', TMessageType.CALL, self._seqid)
        args = delete_table_column_statistics_args()
        args.db_name = db_name
        args.tbl_name = tbl_name
        args.col_name = col_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_delete_table_column_statistics(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = delete_table_column_statistics_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        raise TApplicationException(TApplicationException.MISSING_RESULT, "delete_table_column_statistics failed: unknown result")

    def create_function(self, func):
        """
        Parameters:
         - func
        """
        self.send_create_function(func)
        self.recv_create_function()

    def send_create_function(self, func):
        self._oprot.writeMessageBegin('create_function', TMessageType.CALL, self._seqid)
        args = create_function_args()
        args.func = func
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_function(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_function_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        if result.o4 is not None:
            raise result.o4
        return

    def drop_function(self, dbName, funcName):
        """
        Parameters:
         - dbName
         - funcName
        """
        self.send_drop_function(dbName, funcName)
        self.recv_drop_function()

    def send_drop_function(self, dbName, funcName):
        self._oprot.writeMessageBegin('drop_function', TMessageType.CALL, self._seqid)
        args = drop_function_args()
        args.dbName = dbName
        args.funcName = funcName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_function(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_function_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o3 is not None:
            raise result.o3
        return

    def alter_function(self, dbName, funcName, newFunc):
        """
        Parameters:
         - dbName
         - funcName
         - newFunc
        """
        self.send_alter_function(dbName, funcName, newFunc)
        self.recv_alter_function()

    def send_alter_function(self, dbName, funcName, newFunc):
        self._oprot.writeMessageBegin('alter_function', TMessageType.CALL, self._seqid)
        args = alter_function_args()
        args.dbName = dbName
        args.funcName = funcName
        args.newFunc = newFunc
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_alter_function(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = alter_function_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def get_functions(self, dbName, pattern):
        """
        Parameters:
         - dbName
         - pattern
        """
        self.send_get_functions(dbName, pattern)
        return self.recv_get_functions()

    def send_get_functions(self, dbName, pattern):
        self._oprot.writeMessageBegin('get_functions', TMessageType.CALL, self._seqid)
        args = get_functions_args()
        args.dbName = dbName
        args.pattern = pattern
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_functions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_functions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_functions failed: unknown result")

    def get_function(self, dbName, funcName):
        """
        Parameters:
         - dbName
         - funcName
        """
        self.send_get_function(dbName, funcName)
        return self.recv_get_function()

    def send_get_function(self, dbName, funcName):
        self._oprot.writeMessageBegin('get_function', TMessageType.CALL, self._seqid)
        args = get_function_args()
        args.dbName = dbName
        args.funcName = funcName
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_function(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_function_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_function failed: unknown result")

    def get_all_functions(self):
        self.send_get_all_functions()
        return self.recv_get_all_functions()

    def send_get_all_functions(self):
        self._oprot.writeMessageBegin('get_all_functions', TMessageType.CALL, self._seqid)
        args = get_all_functions_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_all_functions(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_all_functions_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_all_functions failed: unknown result")

    def create_role(self, role):
        """
        Parameters:
         - role
        """
        self.send_create_role(role)
        return self.recv_create_role()

    def send_create_role(self, role):
        self._oprot.writeMessageBegin('create_role', TMessageType.CALL, self._seqid)
        args = create_role_args()
        args.role = role
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_create_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = create_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "create_role failed: unknown result")

    def drop_role(self, role_name):
        """
        Parameters:
         - role_name
        """
        self.send_drop_role(role_name)
        return self.recv_drop_role()

    def send_drop_role(self, role_name):
        self._oprot.writeMessageBegin('drop_role', TMessageType.CALL, self._seqid)
        args = drop_role_args()
        args.role_name = role_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_drop_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = drop_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "drop_role failed: unknown result")

    def get_role_names(self):
        self.send_get_role_names()
        return self.recv_get_role_names()

    def send_get_role_names(self):
        self._oprot.writeMessageBegin('get_role_names', TMessageType.CALL, self._seqid)
        args = get_role_names_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_role_names(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_role_names_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_role_names failed: unknown result")

    def grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
        """
        Parameters:
         - role_name
         - principal_name
         - principal_type
         - grantor
         - grantorType
         - grant_option
        """
        self.send_grant_role(role_name, principal_name, principal_type, grantor, grantorType, grant_option)
        return self.recv_grant_role()

    def send_grant_role(self, role_name, principal_name, principal_type, grantor, grantorType, grant_option):
        self._oprot.writeMessageBegin('grant_role', TMessageType.CALL, self._seqid)
        args = grant_role_args()
        args.role_name = role_name
        args.principal_name = principal_name
        args.principal_type = principal_type
        args.grantor = grantor
        args.grantorType = grantorType
        args.grant_option = grant_option
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_grant_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = grant_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_role failed: unknown result")

    def revoke_role(self, role_name, principal_name, principal_type):
        """
        Parameters:
         - role_name
         - principal_name
         - principal_type
        """
        self.send_revoke_role(role_name, principal_name, principal_type)
        return self.recv_revoke_role()

    def send_revoke_role(self, role_name, principal_name, principal_type):
        self._oprot.writeMessageBegin('revoke_role', TMessageType.CALL, self._seqid)
        args = revoke_role_args()
        args.role_name = role_name
        args.principal_name = principal_name
        args.principal_type = principal_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revoke_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revoke_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "revoke_role failed: unknown result")

    def list_roles(self, principal_name, principal_type):
        """
        Parameters:
         - principal_name
         - principal_type
        """
        self.send_list_roles(principal_name, principal_type)
        return self.recv_list_roles()

    def send_list_roles(self, principal_name, principal_type):
        self._oprot.writeMessageBegin('list_roles', TMessageType.CALL, self._seqid)
        args = list_roles_args()
        args.principal_name = principal_name
        args.principal_type = principal_type
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_list_roles(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = list_roles_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "list_roles failed: unknown result")

    def grant_revoke_role(self, request):
        """
        Parameters:
         - request
        """
        self.send_grant_revoke_role(request)
        return self.recv_grant_revoke_role()

    def send_grant_revoke_role(self, request):
        self._oprot.writeMessageBegin('grant_revoke_role', TMessageType.CALL, self._seqid)
        args = grant_revoke_role_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_grant_revoke_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = grant_revoke_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_revoke_role failed: unknown result")

    def get_principals_in_role(self, request):
        """
        Parameters:
         - request
        """
        self.send_get_principals_in_role(request)
        return self.recv_get_principals_in_role()

    def send_get_principals_in_role(self, request):
        self._oprot.writeMessageBegin('get_principals_in_role', TMessageType.CALL, self._seqid)
        args = get_principals_in_role_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_principals_in_role(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_principals_in_role_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_principals_in_role failed: unknown result")

    def get_role_grants_for_principal(self, request):
        """
        Parameters:
         - request
        """
        self.send_get_role_grants_for_principal(request)
        return self.recv_get_role_grants_for_principal()

    def send_get_role_grants_for_principal(self, request):
        self._oprot.writeMessageBegin('get_role_grants_for_principal', TMessageType.CALL, self._seqid)
        args = get_role_grants_for_principal_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_role_grants_for_principal(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_role_grants_for_principal_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_role_grants_for_principal failed: unknown result")

    def get_privilege_set(self, hiveObject, user_name, group_names):
        """
        Parameters:
         - hiveObject
         - user_name
         - group_names
        """
        self.send_get_privilege_set(hiveObject, user_name, group_names)
        return self.recv_get_privilege_set()

    def send_get_privilege_set(self, hiveObject, user_name, group_names):
        self._oprot.writeMessageBegin('get_privilege_set', TMessageType.CALL, self._seqid)
        args = get_privilege_set_args()
        args.hiveObject = hiveObject
        args.user_name = user_name
        args.group_names = group_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_privilege_set(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_privilege_set_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_privilege_set failed: unknown result")

    def list_privileges(self, principal_name, principal_type, hiveObject):
        """
        Parameters:
         - principal_name
         - principal_type
         - hiveObject
        """
        self.send_list_privileges(principal_name, principal_type, hiveObject)
        return self.recv_list_privileges()

    def send_list_privileges(self, principal_name, principal_type, hiveObject):
        self._oprot.writeMessageBegin('list_privileges', TMessageType.CALL, self._seqid)
        args = list_privileges_args()
        args.principal_name = principal_name
        args.principal_type = principal_type
        args.hiveObject = hiveObject
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_list_privileges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = list_privileges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "list_privileges failed: unknown result")

    def grant_privileges(self, privileges):
        """
        Parameters:
         - privileges
        """
        self.send_grant_privileges(privileges)
        return self.recv_grant_privileges()

    def send_grant_privileges(self, privileges):
        self._oprot.writeMessageBegin('grant_privileges', TMessageType.CALL, self._seqid)
        args = grant_privileges_args()
        args.privileges = privileges
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_grant_privileges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = grant_privileges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_privileges failed: unknown result")

    def revoke_privileges(self, privileges):
        """
        Parameters:
         - privileges
        """
        self.send_revoke_privileges(privileges)
        return self.recv_revoke_privileges()

    def send_revoke_privileges(self, privileges):
        self._oprot.writeMessageBegin('revoke_privileges', TMessageType.CALL, self._seqid)
        args = revoke_privileges_args()
        args.privileges = privileges
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_revoke_privileges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = revoke_privileges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "revoke_privileges failed: unknown result")

    def grant_revoke_privileges(self, request):
        """
        Parameters:
         - request
        """
        self.send_grant_revoke_privileges(request)
        return self.recv_grant_revoke_privileges()

    def send_grant_revoke_privileges(self, request):
        self._oprot.writeMessageBegin('grant_revoke_privileges', TMessageType.CALL, self._seqid)
        args = grant_revoke_privileges_args()
        args.request = request
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_grant_revoke_privileges(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = grant_revoke_privileges_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "grant_revoke_privileges failed: unknown result")

    def set_ugi(self, user_name, group_names):
        """
        Parameters:
         - user_name
         - group_names
        """
        self.send_set_ugi(user_name, group_names)
        return self.recv_set_ugi()

    def send_set_ugi(self, user_name, group_names):
        self._oprot.writeMessageBegin('set_ugi', TMessageType.CALL, self._seqid)
        args = set_ugi_args()
        args.user_name = user_name
        args.group_names = group_names
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_set_ugi(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = set_ugi_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "set_ugi failed: unknown result")

    def get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
        """
        Parameters:
         - token_owner
         - renewer_kerberos_principal_name
        """
        self.send_get_delegation_token(token_owner, renewer_kerberos_principal_name)
        return self.recv_get_delegation_token()

    def send_get_delegation_token(self, token_owner, renewer_kerberos_principal_name):
        self._oprot.writeMessageBegin('get_delegation_token', TMessageType.CALL, self._seqid)
        args = get_delegation_token_args()
        args.token_owner = token_owner
        args.renewer_kerberos_principal_name = renewer_kerberos_principal_name
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_delegation_token(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_delegation_token_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_delegation_token failed: unknown result")

    def renew_delegation_token(self, token_str_form):
        """
        Parameters:
         - token_str_form
        """
        self.send_renew_delegation_token(token_str_form)
        return self.recv_renew_delegation_token()

    def send_renew_delegation_token(self, token_str_form):
        self._oprot.writeMessageBegin('renew_delegation_token', TMessageType.CALL, self._seqid)
        args = renew_delegation_token_args()
        args.token_str_form = token_str_form
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_renew_delegation_token(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = renew_delegation_token_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        raise TApplicationException(TApplicationException.MISSING_RESULT, "renew_delegation_token failed: unknown result")

    def cancel_delegation_token(self, token_str_form):
        """
        Parameters:
         - token_str_form
        """
        self.send_cancel_delegation_token(token_str_form)
        self.recv_cancel_delegation_token()

    def send_cancel_delegation_token(self, token_str_form):
        self._oprot.writeMessageBegin('cancel_delegation_token', TMessageType.CALL, self._seqid)
        args = cancel_delegation_token_args()
        args.token_str_form = token_str_form
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_cancel_delegation_token(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = cancel_delegation_token_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def get_open_txns(self):
        self.send_get_open_txns()
        return self.recv_get_open_txns()

    def send_get_open_txns(self):
        self._oprot.writeMessageBegin('get_open_txns', TMessageType.CALL, self._seqid)
        args = get_open_txns_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_open_txns(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_open_txns_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_open_txns failed: unknown result")

    def get_open_txns_info(self):
        self.send_get_open_txns_info()
        return self.recv_get_open_txns_info()

    def send_get_open_txns_info(self):
        self._oprot.writeMessageBegin('get_open_txns_info', TMessageType.CALL, self._seqid)
        args = get_open_txns_info_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_open_txns_info(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_open_txns_info_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_open_txns_info failed: unknown result")

    def open_txns(self, rqst):
        """
        Parameters:
         - rqst
        """
        self.send_open_txns(rqst)
        return self.recv_open_txns()

    def send_open_txns(self, rqst):
        self._oprot.writeMessageBegin('open_txns', TMessageType.CALL, self._seqid)
        args = open_txns_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_open_txns(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = open_txns_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "open_txns failed: unknown result")

    def abort_txn(self, rqst):
        """
        Parameters:
         - rqst
        """
        self.send_abort_txn(rqst)
        self.recv_abort_txn()

    def send_abort_txn(self, rqst):
        self._oprot.writeMessageBegin('abort_txn', TMessageType.CALL, self._seqid)
        args = abort_txn_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_abort_txn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = abort_txn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        return

    def commit_txn(self, rqst):
        """
        Parameters:
         - rqst
        """
        self.send_commit_txn(rqst)
        self.recv_commit_txn()

    def send_commit_txn(self, rqst):
        self._oprot.writeMessageBegin('commit_txn', TMessageType.CALL, self._seqid)
        args = commit_txn_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_commit_txn(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = commit_txn_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def lock(self, rqst):
        """
        Parameters:
         - rqst
        """
        self.send_lock(rqst)
        return self.recv_lock()

    def send_lock(self, rqst):
        self._oprot.writeMessageBegin('lock', TMessageType.CALL, self._seqid)
        args = lock_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_lock(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = lock_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        raise TApplicationException(TApplicationException.MISSING_RESULT, "lock failed: unknown result")

    def check_lock(self, rqst):
        """
        Parameters:
         - rqst
        """
        self.send_check_lock(rqst)
        return self.recv_check_lock()

    def send_check_lock(self, rqst):
        self._oprot.writeMessageBegin('check_lock', TMessageType.CALL, self._seqid)
        args = check_lock_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_check_lock(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = check_lock_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        raise TApplicationException(TApplicationException.MISSING_RESULT, "check_lock failed: unknown result")

    def unlock(self, rqst):
        """
        Parameters:
         - rqst
        """
        self.send_unlock(rqst)
        self.recv_unlock()

    def send_unlock(self, rqst):
        self._oprot.writeMessageBegin('unlock', TMessageType.CALL, self._seqid)
        args = unlock_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_unlock(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = unlock_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        return

    def show_locks(self, rqst):
        """
        Parameters:
         - rqst
        """
        self.send_show_locks(rqst)
        return self.recv_show_locks()

    def send_show_locks(self, rqst):
        self._oprot.writeMessageBegin('show_locks', TMessageType.CALL, self._seqid)
        args = show_locks_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_show_locks(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = show_locks_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "show_locks failed: unknown result")

    def heartbeat(self, ids):
        """
        Parameters:
         - ids
        """
        self.send_heartbeat(ids)
        self.recv_heartbeat()

    def send_heartbeat(self, ids):
        self._oprot.writeMessageBegin('heartbeat', TMessageType.CALL, self._seqid)
        args = heartbeat_args()
        args.ids = ids
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_heartbeat(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = heartbeat_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.o1 is not None:
            raise result.o1
        if result.o2 is not None:
            raise result.o2
        if result.o3 is not None:
            raise result.o3
        return

    def heartbeat_txn_range(self, txns):
        """
        Parameters:
         - txns
        """
        self.send_heartbeat_txn_range(txns)
        return self.recv_heartbeat_txn_range()

    def send_heartbeat_txn_range(self, txns):
        self._oprot.writeMessageBegin('heartbeat_txn_range', TMessageType.CALL, self._seqid)
        args = heartbeat_txn_range_args()
        args.txns = txns
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_heartbeat_txn_range(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = heartbeat_txn_range_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "heartbeat_txn_range failed: unknown result")

    def compact(self, rqst):
        """
        Parameters:
         - rqst
        """
        self.send_compact(rqst)
        self.recv_compact()

    def send_compact(self, rqst):
        self._oprot.writeMessageBegin('compact', TMessageType.CALL, self._seqid)
        args = compact_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_compact(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = compact_result()
        result.read(iprot)
        iprot.readMessageEnd()
        return

    def show_compact(self, rqst):
        """
        Parameters:
         - rqst
        """
        self.send_show_compact(rqst)
        return self.recv_show_compact()

    def send_show_compact(self, rqst):
        self._oprot.writeMessageBegin('show_compact', TMessageType.CALL, self._seqid)
        args = show_compact_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_show_compact(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = show_compact_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "show_compact failed: unknown result")

    def get_next_notification(self, rqst):
        """
        Parameters:
         - rqst
        """
        self.send_get_next_notification(rqst)
        return self.recv_get_next_notification()

    def send_get_next_notification(self, rqst):
        self._oprot.writeMessageBegin('get_next_notification', TMessageType.CALL, self._seqid)
        args = get_next_notification_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_next_notification(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_next_notification_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_next_notification failed: unknown result")

    def get_current_notificationEventId(self):
        self.send_get_current_notificationEventId()
        return self.recv_get_current_notificationEventId()

    def send_get_current_notificationEventId(self):
        self._oprot.writeMessageBegin('get_current_notificationEventId', TMessageType.CALL, self._seqid)
        args = get_current_notificationEventId_args()
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_get_current_notificationEventId(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = get_current_notificationEventId_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "get_current_notificationEventId failed: unknown result")

    def fire_listener_event(self, rqst):
        """
        Parameters:
         - rqst
        """
        self.send_fire_listener_event(rqst)
        return self.recv_fire_listener_event()

    def send_fire_listener_event(self, rqst):
        self._oprot.writeMessageBegin('fire_listener_event', TMessageType.CALL, self._seqid)
        args = fire_listener_event_args()
        args.rqst = rqst
        args.write(self._oprot)
        self._oprot.writeMessageEnd()
        self._oprot.trans.flush()

    def recv_fire_listener_event(self):
        iprot = self._iprot
        (fname, mtype, rseqid) = iprot.readMessageBegin()
        if mtype == TMessageType.EXCEPTION:
            x = TApplicationException()
            x.read(iprot)
            iprot.readMessageEnd()
            raise x
        result = fire_listener_event_result()
        result.read(iprot)
        iprot.readMessageEnd()
        if result.success is not None:
            return result.success
        raise TApplicationException(TApplicationException.MISSING_RESULT, "fire_listener_event failed: unknown result")


class Processor(impala._thrift_gen.fb303.FacebookService.Processor, Iface, TProcessor):
    def __init__(self, handler):
        impala._thrift_gen.fb303.FacebookService.Processor.__init__(self, handler)
        self._processMap["getMetaConf"] = Processor.process_getMetaConf
        self._processMap["setMetaConf"] = Processor.process_setMetaConf
        self._processMap["create_database"] = Processor.process_create_database
        self._processMap["get_database"] = Processor.process_get_database
        self._processMap["drop_database"] = Processor.process_drop_database
        self._processMap["get_databases"] = Processor.process_get_databases
        self._processMap["get_all_databases"] = Processor.process_get_all_databases
        self._processMap["alter_database"] = Processor.process_alter_database
        self._processMap["get_type"] = Processor.process_get_type
        self._processMap["create_type"] = Processor.process_create_type
        self._processMap["drop_type"] = Processor.process_drop_type
        self._processMap["get_type_all"] = Processor.process_get_type_all
        self._processMap["get_fields"] = Processor.process_get_fields
        self._processMap["get_fields_with_environment_context"] = Processor.process_get_fields_with_environment_context
        self._processMap["get_schema"] = Processor.process_get_schema
        self._processMap["get_schema_with_environment_context"] = Processor.process_get_schema_with_environment_context
        self._processMap["create_table"] = Processor.process_create_table
        self._processMap["create_table_with_environment_context"] = Processor.process_create_table_with_environment_context
        self._processMap["drop_table"] = Processor.process_drop_table
        self._processMap["drop_table_with_environment_context"] = Processor.process_drop_table_with_environment_context
        self._processMap["get_tables"] = Processor.process_get_tables
        self._processMap["get_table_meta"] = Processor.process_get_table_meta
        self._processMap["get_all_tables"] = Processor.process_get_all_tables
        self._processMap["get_table"] = Processor.process_get_table
        self._processMap["get_table_objects_by_name"] = Processor.process_get_table_objects_by_name
        self._processMap["get_table_names_by_filter"] = Processor.process_get_table_names_by_filter
        self._processMap["alter_table"] = Processor.process_alter_table
        self._processMap["alter_table_with_environment_context"] = Processor.process_alter_table_with_environment_context
        self._processMap["alter_table_with_cascade"] = Processor.process_alter_table_with_cascade
        self._processMap["add_partition"] = Processor.process_add_partition
        self._processMap["add_partition_with_environment_context"] = Processor.process_add_partition_with_environment_context
        self._processMap["add_partitions"] = Processor.process_add_partitions
        self._processMap["add_partitions_pspec"] = Processor.process_add_partitions_pspec
        self._processMap["append_partition"] = Processor.process_append_partition
        self._processMap["add_partitions_req"] = Processor.process_add_partitions_req
        self._processMap["append_partition_with_environment_context"] = Processor.process_append_partition_with_environment_context
        self._processMap["append_partition_by_name"] = Processor.process_append_partition_by_name
        self._processMap["append_partition_by_name_with_environment_context"] = Processor.process_append_partition_by_name_with_environment_context
        self._processMap["drop_partition"] = Processor.process_drop_partition
        self._processMap["drop_partition_with_environment_context"] = Processor.process_drop_partition_with_environment_context
        self._processMap["drop_partition_by_name"] = Processor.process_drop_partition_by_name
        self._processMap["drop_partition_by_name_with_environment_context"] = Processor.process_drop_partition_by_name_with_environment_context
        self._processMap["drop_partitions_req"] = Processor.process_drop_partitions_req
        self._processMap["get_partition"] = Processor.process_get_partition
        self._processMap["exchange_partition"] = Processor.process_exchange_partition
        self._processMap["exchange_partitions"] = Processor.process_exchange_partitions
        self._processMap["get_partition_with_auth"] = Processor.process_get_partition_with_auth
        self._processMap["get_partition_by_name"] = Processor.process_get_partition_by_name
        self._processMap["get_partitions"] = Processor.process_get_partitions
        self._processMap["get_partitions_with_auth"] = Processor.process_get_partitions_with_auth
        self._processMap["get_partitions_pspec"] = Processor.process_get_partitions_pspec
        self._processMap["get_partition_names"] = Processor.process_get_partition_names
        self._processMap["get_partitions_ps"] = Processor.process_get_partitions_ps
        self._processMap["get_partitions_ps_with_auth"] = Processor.process_get_partitions_ps_with_auth
        self._processMap["get_partition_names_ps"] = Processor.process_get_partition_names_ps
        self._processMap["get_partitions_by_filter"] = Processor.process_get_partitions_by_filter
        self._processMap["get_part_specs_by_filter"] = Processor.process_get_part_specs_by_filter
        self._processMap["get_partitions_by_expr"] = Processor.process_get_partitions_by_expr
        self._processMap["get_partitions_by_names"] = Processor.process_get_partitions_by_names
        self._processMap["alter_partition"] = Processor.process_alter_partition
        self._processMap["alter_partitions"] = Processor.process_alter_partitions
        self._processMap["alter_partition_with_environment_context"] = Processor.process_alter_partition_with_environment_context
        self._processMap["rename_partition"] = Processor.process_rename_partition
        self._processMap["partition_name_has_valid_characters"] = Processor.process_partition_name_has_valid_characters
        self._processMap["get_config_value"] = Processor.process_get_config_value
        self._processMap["partition_name_to_vals"] = Processor.process_partition_name_to_vals
        self._processMap["partition_name_to_spec"] = Processor.process_partition_name_to_spec
        self._processMap["markPartitionForEvent"] = Processor.process_markPartitionForEvent
        self._processMap["isPartitionMarkedForEvent"] = Processor.process_isPartitionMarkedForEvent
        self._processMap["add_index"] = Processor.process_add_index
        self._processMap["alter_index"] = Processor.process_alter_index
        self._processMap["drop_index_by_name"] = Processor.process_drop_index_by_name
        self._processMap["get_index_by_name"] = Processor.process_get_index_by_name
        self._processMap["get_indexes"] = Processor.process_get_indexes
        self._processMap["get_index_names"] = Processor.process_get_index_names
        self._processMap["update_table_column_statistics"] = Processor.process_update_table_column_statistics
        self._processMap["update_partition_column_statistics"] = Processor.process_update_partition_column_statistics
        self._processMap["get_table_column_statistics"] = Processor.process_get_table_column_statistics
        self._processMap["get_partition_column_statistics"] = Processor.process_get_partition_column_statistics
        self._processMap["get_table_statistics_req"] = Processor.process_get_table_statistics_req
        self._processMap["get_partitions_statistics_req"] = Processor.process_get_partitions_statistics_req
        self._processMap["get_aggr_stats_for"] = Processor.process_get_aggr_stats_for
        self._processMap["set_aggr_stats_for"] = Processor.process_set_aggr_stats_for
        self._processMap["delete_partition_column_statistics"] = Processor.process_delete_partition_column_statistics
        self._processMap["delete_table_column_statistics"] = Processor.process_delete_table_column_statistics
        self._processMap["create_function"] = Processor.process_create_function
        self._processMap["drop_function"] = Processor.process_drop_function
        self._processMap["alter_function"] = Processor.process_alter_function
        self._processMap["get_functions"] = Processor.process_get_functions
        self._processMap["get_function"] = Processor.process_get_function
        self._processMap["get_all_functions"] = Processor.process_get_all_functions
        self._processMap["create_role"] = Processor.process_create_role
        self._processMap["drop_role"] = Processor.process_drop_role
        self._processMap["get_role_names"] = Processor.process_get_role_names
        self._processMap["grant_role"] = Processor.process_grant_role
        self._processMap["revoke_role"] = Processor.process_revoke_role
        self._processMap["list_roles"] = Processor.process_list_roles
        self._processMap["grant_revoke_role"] = Processor.process_grant_revoke_role
        self._processMap["get_principals_in_role"] = Processor.process_get_principals_in_role
        self._processMap["get_role_grants_for_principal"] = Processor.process_get_role_grants_for_principal
        self._processMap["get_privilege_set"] = Processor.process_get_privilege_set
        self._processMap["list_privileges"] = Processor.process_list_privileges
        self._processMap["grant_privileges"] = Processor.process_grant_privileges
        self._processMap["revoke_privileges"] = Processor.process_revoke_privileges
        self._processMap["grant_revoke_privileges"] = Processor.process_grant_revoke_privileges
        self._processMap["set_ugi"] = Processor.process_set_ugi
        self._processMap["get_delegation_token"] = Processor.process_get_delegation_token
        self._processMap["renew_delegation_token"] = Processor.process_renew_delegation_token
        self._processMap["cancel_delegation_token"] = Processor.process_cancel_delegation_token
        self._processMap["get_open_txns"] = Processor.process_get_open_txns
        self._processMap["get_open_txns_info"] = Processor.process_get_open_txns_info
        self._processMap["open_txns"] = Processor.process_open_txns
        self._processMap["abort_txn"] = Processor.process_abort_txn
        self._processMap["commit_txn"] = Processor.process_commit_txn
        self._processMap["lock"] = Processor.process_lock
        self._processMap["check_lock"] = Processor.process_check_lock
        self._processMap["unlock"] = Processor.process_unlock
        self._processMap["show_locks"] = Processor.process_show_locks
        self._processMap["heartbeat"] = Processor.process_heartbeat
        self._processMap["heartbeat_txn_range"] = Processor.process_heartbeat_txn_range
        self._processMap["compact"] = Processor.process_compact
        self._processMap["show_compact"] = Processor.process_show_compact
        self._processMap["get_next_notification"] = Processor.process_get_next_notification
        self._processMap["get_current_notificationEventId"] = Processor.process_get_current_notificationEventId
        self._processMap["fire_listener_event"] = Processor.process_fire_listener_event

    def process(self, iprot, oprot):
        (name, type, seqid) = iprot.readMessageBegin()
        if name not in self._processMap:
            iprot.skip(TType.STRUCT)
            iprot.readMessageEnd()
            x = TApplicationException(TApplicationException.UNKNOWN_METHOD, 'Unknown function %s' % (name))
            oprot.writeMessageBegin(name, TMessageType.EXCEPTION, seqid)
            x.write(oprot)
            oprot.writeMessageEnd()
            oprot.trans.flush()
            return
        else:
            self._processMap[name](self, seqid, iprot, oprot)
        return True

    def process_getMetaConf(self, seqid, iprot, oprot):
        args = getMetaConf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = getMetaConf_result()
        try:
            result.success = self._handler.getMetaConf(args.key)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("getMetaConf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_setMetaConf(self, seqid, iprot, oprot):
        args = setMetaConf_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = setMetaConf_result()
        try:
            self._handler.setMetaConf(args.key, args.value)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("setMetaConf", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_database(self, seqid, iprot, oprot):
        args = create_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_database_result()
        try:
            self._handler.create_database(args.database)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_database(self, seqid, iprot, oprot):
        args = get_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_database_result()
        try:
            result.success = self._handler.get_database(args.name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_database(self, seqid, iprot, oprot):
        args = drop_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_database_result()
        try:
            self._handler.drop_database(args.name, args.deleteData, args.cascade)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_databases(self, seqid, iprot, oprot):
        args = get_databases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_databases_result()
        try:
            result.success = self._handler.get_databases(args.pattern)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_databases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_databases(self, seqid, iprot, oprot):
        args = get_all_databases_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_databases_result()
        try:
            result.success = self._handler.get_all_databases()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_databases", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_database(self, seqid, iprot, oprot):
        args = alter_database_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_database_result()
        try:
            self._handler.alter_database(args.dbname, args.db)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_database", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_type(self, seqid, iprot, oprot):
        args = get_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_type_result()
        try:
            result.success = self._handler.get_type(args.name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_type(self, seqid, iprot, oprot):
        args = create_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_type_result()
        try:
            result.success = self._handler.create_type(args.type)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_type(self, seqid, iprot, oprot):
        args = drop_type_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_type_result()
        try:
            result.success = self._handler.drop_type(args.type)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_type", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_type_all(self, seqid, iprot, oprot):
        args = get_type_all_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_type_all_result()
        try:
            result.success = self._handler.get_type_all(args.name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_type_all", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_fields(self, seqid, iprot, oprot):
        args = get_fields_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_fields_result()
        try:
            result.success = self._handler.get_fields(args.db_name, args.table_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except UnknownTableException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_fields", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_fields_with_environment_context(self, seqid, iprot, oprot):
        args = get_fields_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_fields_with_environment_context_result()
        try:
            result.success = self._handler.get_fields_with_environment_context(args.db_name, args.table_name, args.environment_context)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except UnknownTableException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_fields_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schema(self, seqid, iprot, oprot):
        args = get_schema_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schema_result()
        try:
            result.success = self._handler.get_schema(args.db_name, args.table_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except UnknownTableException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_schema", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_schema_with_environment_context(self, seqid, iprot, oprot):
        args = get_schema_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_schema_with_environment_context_result()
        try:
            result.success = self._handler.get_schema_with_environment_context(args.db_name, args.table_name, args.environment_context)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except UnknownTableException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_schema_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_table(self, seqid, iprot, oprot):
        args = create_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_table_result()
        try:
            self._handler.create_table(args.tbl)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except NoSuchObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_table_with_environment_context(self, seqid, iprot, oprot):
        args = create_table_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_table_with_environment_context_result()
        try:
            self._handler.create_table_with_environment_context(args.tbl, args.environment_context)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except NoSuchObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_table_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_table(self, seqid, iprot, oprot):
        args = drop_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_table_result()
        try:
            self._handler.drop_table(args.dbname, args.name, args.deleteData)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_table_with_environment_context(self, seqid, iprot, oprot):
        args = drop_table_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_table_with_environment_context_result()
        try:
            self._handler.drop_table_with_environment_context(args.dbname, args.name, args.deleteData, args.environment_context)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_table_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_tables(self, seqid, iprot, oprot):
        args = get_tables_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_tables_result()
        try:
            result.success = self._handler.get_tables(args.db_name, args.pattern)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_tables", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_meta(self, seqid, iprot, oprot):
        args = get_table_meta_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_meta_result()
        try:
            result.success = self._handler.get_table_meta(args.db_patterns, args.tbl_patterns, args.tbl_types)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_meta", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_tables(self, seqid, iprot, oprot):
        args = get_all_tables_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_tables_result()
        try:
            result.success = self._handler.get_all_tables(args.db_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_tables", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table(self, seqid, iprot, oprot):
        args = get_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_result()
        try:
            result.success = self._handler.get_table(args.dbname, args.tbl_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_objects_by_name(self, seqid, iprot, oprot):
        args = get_table_objects_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_objects_by_name_result()
        try:
            result.success = self._handler.get_table_objects_by_name(args.dbname, args.tbl_names)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_objects_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_names_by_filter(self, seqid, iprot, oprot):
        args = get_table_names_by_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_names_by_filter_result()
        try:
            result.success = self._handler.get_table_names_by_filter(args.dbname, args.filter, args.max_tables)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidOperationException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_names_by_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_table(self, seqid, iprot, oprot):
        args = alter_table_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_table_result()
        try:
            self._handler.alter_table(args.dbname, args.tbl_name, args.new_tbl)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_table", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_table_with_environment_context(self, seqid, iprot, oprot):
        args = alter_table_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_table_with_environment_context_result()
        try:
            self._handler.alter_table_with_environment_context(args.dbname, args.tbl_name, args.new_tbl, args.environment_context)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_table_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_table_with_cascade(self, seqid, iprot, oprot):
        args = alter_table_with_cascade_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_table_with_cascade_result()
        try:
            self._handler.alter_table_with_cascade(args.dbname, args.tbl_name, args.new_tbl, args.cascade)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_table_with_cascade", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_partition(self, seqid, iprot, oprot):
        args = add_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_partition_result()
        try:
            result.success = self._handler.add_partition(args.new_part)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_partition_with_environment_context(self, seqid, iprot, oprot):
        args = add_partition_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_partition_with_environment_context_result()
        try:
            result.success = self._handler.add_partition_with_environment_context(args.new_part, args.environment_context)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_partition_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_partitions(self, seqid, iprot, oprot):
        args = add_partitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_partitions_result()
        try:
            result.success = self._handler.add_partitions(args.new_parts)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_partitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_partitions_pspec(self, seqid, iprot, oprot):
        args = add_partitions_pspec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_partitions_pspec_result()
        try:
            result.success = self._handler.add_partitions_pspec(args.new_parts)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_partitions_pspec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_append_partition(self, seqid, iprot, oprot):
        args = append_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = append_partition_result()
        try:
            result.success = self._handler.append_partition(args.db_name, args.tbl_name, args.part_vals)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("append_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_partitions_req(self, seqid, iprot, oprot):
        args = add_partitions_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_partitions_req_result()
        try:
            result.success = self._handler.add_partitions_req(args.request)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_partitions_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_append_partition_with_environment_context(self, seqid, iprot, oprot):
        args = append_partition_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = append_partition_with_environment_context_result()
        try:
            result.success = self._handler.append_partition_with_environment_context(args.db_name, args.tbl_name, args.part_vals, args.environment_context)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("append_partition_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_append_partition_by_name(self, seqid, iprot, oprot):
        args = append_partition_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = append_partition_by_name_result()
        try:
            result.success = self._handler.append_partition_by_name(args.db_name, args.tbl_name, args.part_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("append_partition_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_append_partition_by_name_with_environment_context(self, seqid, iprot, oprot):
        args = append_partition_by_name_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = append_partition_by_name_with_environment_context_result()
        try:
            result.success = self._handler.append_partition_by_name_with_environment_context(args.db_name, args.tbl_name, args.part_name, args.environment_context)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("append_partition_by_name_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_partition(self, seqid, iprot, oprot):
        args = drop_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_partition_result()
        try:
            result.success = self._handler.drop_partition(args.db_name, args.tbl_name, args.part_vals, args.deleteData)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_partition_with_environment_context(self, seqid, iprot, oprot):
        args = drop_partition_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_partition_with_environment_context_result()
        try:
            result.success = self._handler.drop_partition_with_environment_context(args.db_name, args.tbl_name, args.part_vals, args.deleteData, args.environment_context)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_partition_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_partition_by_name(self, seqid, iprot, oprot):
        args = drop_partition_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_partition_by_name_result()
        try:
            result.success = self._handler.drop_partition_by_name(args.db_name, args.tbl_name, args.part_name, args.deleteData)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_partition_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_partition_by_name_with_environment_context(self, seqid, iprot, oprot):
        args = drop_partition_by_name_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_partition_by_name_with_environment_context_result()
        try:
            result.success = self._handler.drop_partition_by_name_with_environment_context(args.db_name, args.tbl_name, args.part_name, args.deleteData, args.environment_context)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_partition_by_name_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_partitions_req(self, seqid, iprot, oprot):
        args = drop_partitions_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_partitions_req_result()
        try:
            result.success = self._handler.drop_partitions_req(args.req)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_partitions_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition(self, seqid, iprot, oprot):
        args = get_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_result()
        try:
            result.success = self._handler.get_partition(args.db_name, args.tbl_name, args.part_vals)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exchange_partition(self, seqid, iprot, oprot):
        args = exchange_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exchange_partition_result()
        try:
            result.success = self._handler.exchange_partition(args.partitionSpecs, args.source_db, args.source_table_name, args.dest_db, args.dest_table_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("exchange_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_exchange_partitions(self, seqid, iprot, oprot):
        args = exchange_partitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = exchange_partitions_result()
        try:
            result.success = self._handler.exchange_partitions(args.partitionSpecs, args.source_db, args.source_table_name, args.dest_db, args.dest_table_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("exchange_partitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_with_auth(self, seqid, iprot, oprot):
        args = get_partition_with_auth_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_with_auth_result()
        try:
            result.success = self._handler.get_partition_with_auth(args.db_name, args.tbl_name, args.part_vals, args.user_name, args.group_names)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partition_with_auth", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_by_name(self, seqid, iprot, oprot):
        args = get_partition_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_by_name_result()
        try:
            result.success = self._handler.get_partition_by_name(args.db_name, args.tbl_name, args.part_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partition_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions(self, seqid, iprot, oprot):
        args = get_partitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_result()
        try:
            result.success = self._handler.get_partitions(args.db_name, args.tbl_name, args.max_parts)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_with_auth(self, seqid, iprot, oprot):
        args = get_partitions_with_auth_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_with_auth_result()
        try:
            result.success = self._handler.get_partitions_with_auth(args.db_name, args.tbl_name, args.max_parts, args.user_name, args.group_names)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_with_auth", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_pspec(self, seqid, iprot, oprot):
        args = get_partitions_pspec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_pspec_result()
        try:
            result.success = self._handler.get_partitions_pspec(args.db_name, args.tbl_name, args.max_parts)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_pspec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_names(self, seqid, iprot, oprot):
        args = get_partition_names_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_names_result()
        try:
            result.success = self._handler.get_partition_names(args.db_name, args.tbl_name, args.max_parts)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partition_names", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_ps(self, seqid, iprot, oprot):
        args = get_partitions_ps_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_ps_result()
        try:
            result.success = self._handler.get_partitions_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_ps", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_ps_with_auth(self, seqid, iprot, oprot):
        args = get_partitions_ps_with_auth_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_ps_with_auth_result()
        try:
            result.success = self._handler.get_partitions_ps_with_auth(args.db_name, args.tbl_name, args.part_vals, args.max_parts, args.user_name, args.group_names)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_ps_with_auth", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_names_ps(self, seqid, iprot, oprot):
        args = get_partition_names_ps_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_names_ps_result()
        try:
            result.success = self._handler.get_partition_names_ps(args.db_name, args.tbl_name, args.part_vals, args.max_parts)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partition_names_ps", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_by_filter(self, seqid, iprot, oprot):
        args = get_partitions_by_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_by_filter_result()
        try:
            result.success = self._handler.get_partitions_by_filter(args.db_name, args.tbl_name, args.filter, args.max_parts)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_by_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_part_specs_by_filter(self, seqid, iprot, oprot):
        args = get_part_specs_by_filter_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_part_specs_by_filter_result()
        try:
            result.success = self._handler.get_part_specs_by_filter(args.db_name, args.tbl_name, args.filter, args.max_parts)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_part_specs_by_filter", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_by_expr(self, seqid, iprot, oprot):
        args = get_partitions_by_expr_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_by_expr_result()
        try:
            result.success = self._handler.get_partitions_by_expr(args.req)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_by_expr", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_by_names(self, seqid, iprot, oprot):
        args = get_partitions_by_names_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_by_names_result()
        try:
            result.success = self._handler.get_partitions_by_names(args.db_name, args.tbl_name, args.names)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_by_names", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_partition(self, seqid, iprot, oprot):
        args = alter_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_partition_result()
        try:
            self._handler.alter_partition(args.db_name, args.tbl_name, args.new_part)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_partitions(self, seqid, iprot, oprot):
        args = alter_partitions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_partitions_result()
        try:
            self._handler.alter_partitions(args.db_name, args.tbl_name, args.new_parts)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_partitions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_partition_with_environment_context(self, seqid, iprot, oprot):
        args = alter_partition_with_environment_context_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_partition_with_environment_context_result()
        try:
            self._handler.alter_partition_with_environment_context(args.db_name, args.tbl_name, args.new_part, args.environment_context)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_partition_with_environment_context", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_rename_partition(self, seqid, iprot, oprot):
        args = rename_partition_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = rename_partition_result()
        try:
            self._handler.rename_partition(args.db_name, args.tbl_name, args.part_vals, args.new_part)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("rename_partition", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_partition_name_has_valid_characters(self, seqid, iprot, oprot):
        args = partition_name_has_valid_characters_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = partition_name_has_valid_characters_result()
        try:
            result.success = self._handler.partition_name_has_valid_characters(args.part_vals, args.throw_exception)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("partition_name_has_valid_characters", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_config_value(self, seqid, iprot, oprot):
        args = get_config_value_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_config_value_result()
        try:
            result.success = self._handler.get_config_value(args.name, args.defaultValue)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except ConfigValSecurityException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_config_value", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_partition_name_to_vals(self, seqid, iprot, oprot):
        args = partition_name_to_vals_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = partition_name_to_vals_result()
        try:
            result.success = self._handler.partition_name_to_vals(args.part_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("partition_name_to_vals", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_partition_name_to_spec(self, seqid, iprot, oprot):
        args = partition_name_to_spec_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = partition_name_to_spec_result()
        try:
            result.success = self._handler.partition_name_to_spec(args.part_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("partition_name_to_spec", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_markPartitionForEvent(self, seqid, iprot, oprot):
        args = markPartitionForEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = markPartitionForEvent_result()
        try:
            self._handler.markPartitionForEvent(args.db_name, args.tbl_name, args.part_vals, args.eventType)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except UnknownTableException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except UnknownPartitionException as o5:
            msg_type = TMessageType.REPLY
            result.o5 = o5
        except InvalidPartitionException as o6:
            msg_type = TMessageType.REPLY
            result.o6 = o6
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("markPartitionForEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_isPartitionMarkedForEvent(self, seqid, iprot, oprot):
        args = isPartitionMarkedForEvent_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = isPartitionMarkedForEvent_result()
        try:
            result.success = self._handler.isPartitionMarkedForEvent(args.db_name, args.tbl_name, args.part_vals, args.eventType)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except UnknownDBException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except UnknownTableException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except UnknownPartitionException as o5:
            msg_type = TMessageType.REPLY
            result.o5 = o5
        except InvalidPartitionException as o6:
            msg_type = TMessageType.REPLY
            result.o6 = o6
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("isPartitionMarkedForEvent", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_add_index(self, seqid, iprot, oprot):
        args = add_index_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = add_index_result()
        try:
            result.success = self._handler.add_index(args.new_index, args.index_table)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except AlreadyExistsException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("add_index", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_index(self, seqid, iprot, oprot):
        args = alter_index_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_index_result()
        try:
            self._handler.alter_index(args.dbname, args.base_tbl_name, args.idx_name, args.new_idx)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_index", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_index_by_name(self, seqid, iprot, oprot):
        args = drop_index_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_index_by_name_result()
        try:
            result.success = self._handler.drop_index_by_name(args.db_name, args.tbl_name, args.index_name, args.deleteData)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_index_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_index_by_name(self, seqid, iprot, oprot):
        args = get_index_by_name_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_index_by_name_result()
        try:
            result.success = self._handler.get_index_by_name(args.db_name, args.tbl_name, args.index_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_index_by_name", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_indexes(self, seqid, iprot, oprot):
        args = get_indexes_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_indexes_result()
        try:
            result.success = self._handler.get_indexes(args.db_name, args.tbl_name, args.max_indexes)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_indexes", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_index_names(self, seqid, iprot, oprot):
        args = get_index_names_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_index_names_result()
        try:
            result.success = self._handler.get_index_names(args.db_name, args.tbl_name, args.max_indexes)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_index_names", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_table_column_statistics(self, seqid, iprot, oprot):
        args = update_table_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_table_column_statistics_result()
        try:
            result.success = self._handler.update_table_column_statistics(args.stats_obj)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_table_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_update_partition_column_statistics(self, seqid, iprot, oprot):
        args = update_partition_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = update_partition_column_statistics_result()
        try:
            result.success = self._handler.update_partition_column_statistics(args.stats_obj)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("update_partition_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_column_statistics(self, seqid, iprot, oprot):
        args = get_table_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_column_statistics_result()
        try:
            result.success = self._handler.get_table_column_statistics(args.db_name, args.tbl_name, args.col_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidInputException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partition_column_statistics(self, seqid, iprot, oprot):
        args = get_partition_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partition_column_statistics_result()
        try:
            result.success = self._handler.get_partition_column_statistics(args.db_name, args.tbl_name, args.part_name, args.col_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidInputException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partition_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_table_statistics_req(self, seqid, iprot, oprot):
        args = get_table_statistics_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_table_statistics_req_result()
        try:
            result.success = self._handler.get_table_statistics_req(args.request)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_table_statistics_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_partitions_statistics_req(self, seqid, iprot, oprot):
        args = get_partitions_statistics_req_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_partitions_statistics_req_result()
        try:
            result.success = self._handler.get_partitions_statistics_req(args.request)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_partitions_statistics_req", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_aggr_stats_for(self, seqid, iprot, oprot):
        args = get_aggr_stats_for_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_aggr_stats_for_result()
        try:
            result.success = self._handler.get_aggr_stats_for(args.request)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_aggr_stats_for", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_aggr_stats_for(self, seqid, iprot, oprot):
        args = set_aggr_stats_for_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_aggr_stats_for_result()
        try:
            result.success = self._handler.set_aggr_stats_for(args.request)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_aggr_stats_for", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_partition_column_statistics(self, seqid, iprot, oprot):
        args = delete_partition_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_partition_column_statistics_result()
        try:
            result.success = self._handler.delete_partition_column_statistics(args.db_name, args.tbl_name, args.part_name, args.col_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_partition_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_delete_table_column_statistics(self, seqid, iprot, oprot):
        args = delete_table_column_statistics_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = delete_table_column_statistics_result()
        try:
            result.success = self._handler.delete_table_column_statistics(args.db_name, args.tbl_name, args.col_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except InvalidObjectException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except InvalidInputException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("delete_table_column_statistics", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_function(self, seqid, iprot, oprot):
        args = create_function_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_function_result()
        try:
            self._handler.create_function(args.func)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except AlreadyExistsException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except InvalidObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except NoSuchObjectException as o4:
            msg_type = TMessageType.REPLY
            result.o4 = o4
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_function", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_function(self, seqid, iprot, oprot):
        args = drop_function_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_function_result()
        try:
            self._handler.drop_function(args.dbName, args.funcName)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchObjectException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_function", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_alter_function(self, seqid, iprot, oprot):
        args = alter_function_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = alter_function_result()
        try:
            self._handler.alter_function(args.dbName, args.funcName, args.newFunc)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except InvalidOperationException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except MetaException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("alter_function", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_functions(self, seqid, iprot, oprot):
        args = get_functions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_functions_result()
        try:
            result.success = self._handler.get_functions(args.dbName, args.pattern)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_functions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_function(self, seqid, iprot, oprot):
        args = get_function_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_function_result()
        try:
            result.success = self._handler.get_function(args.dbName, args.funcName)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchObjectException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_function", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_all_functions(self, seqid, iprot, oprot):
        args = get_all_functions_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_all_functions_result()
        try:
            result.success = self._handler.get_all_functions()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_all_functions", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_create_role(self, seqid, iprot, oprot):
        args = create_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = create_role_result()
        try:
            result.success = self._handler.create_role(args.role)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("create_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_drop_role(self, seqid, iprot, oprot):
        args = drop_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = drop_role_result()
        try:
            result.success = self._handler.drop_role(args.role_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("drop_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_role_names(self, seqid, iprot, oprot):
        args = get_role_names_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_role_names_result()
        try:
            result.success = self._handler.get_role_names()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_role_names", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_grant_role(self, seqid, iprot, oprot):
        args = grant_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = grant_role_result()
        try:
            result.success = self._handler.grant_role(args.role_name, args.principal_name, args.principal_type, args.grantor, args.grantorType, args.grant_option)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("grant_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revoke_role(self, seqid, iprot, oprot):
        args = revoke_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revoke_role_result()
        try:
            result.success = self._handler.revoke_role(args.role_name, args.principal_name, args.principal_type)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revoke_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_list_roles(self, seqid, iprot, oprot):
        args = list_roles_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = list_roles_result()
        try:
            result.success = self._handler.list_roles(args.principal_name, args.principal_type)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("list_roles", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_grant_revoke_role(self, seqid, iprot, oprot):
        args = grant_revoke_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = grant_revoke_role_result()
        try:
            result.success = self._handler.grant_revoke_role(args.request)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("grant_revoke_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_principals_in_role(self, seqid, iprot, oprot):
        args = get_principals_in_role_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_principals_in_role_result()
        try:
            result.success = self._handler.get_principals_in_role(args.request)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_principals_in_role", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_role_grants_for_principal(self, seqid, iprot, oprot):
        args = get_role_grants_for_principal_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_role_grants_for_principal_result()
        try:
            result.success = self._handler.get_role_grants_for_principal(args.request)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_role_grants_for_principal", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_privilege_set(self, seqid, iprot, oprot):
        args = get_privilege_set_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_privilege_set_result()
        try:
            result.success = self._handler.get_privilege_set(args.hiveObject, args.user_name, args.group_names)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_privilege_set", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_list_privileges(self, seqid, iprot, oprot):
        args = list_privileges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = list_privileges_result()
        try:
            result.success = self._handler.list_privileges(args.principal_name, args.principal_type, args.hiveObject)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("list_privileges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_grant_privileges(self, seqid, iprot, oprot):
        args = grant_privileges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = grant_privileges_result()
        try:
            result.success = self._handler.grant_privileges(args.privileges)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("grant_privileges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_revoke_privileges(self, seqid, iprot, oprot):
        args = revoke_privileges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = revoke_privileges_result()
        try:
            result.success = self._handler.revoke_privileges(args.privileges)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("revoke_privileges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_grant_revoke_privileges(self, seqid, iprot, oprot):
        args = grant_revoke_privileges_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = grant_revoke_privileges_result()
        try:
            result.success = self._handler.grant_revoke_privileges(args.request)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("grant_revoke_privileges", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_set_ugi(self, seqid, iprot, oprot):
        args = set_ugi_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = set_ugi_result()
        try:
            result.success = self._handler.set_ugi(args.user_name, args.group_names)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("set_ugi", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_delegation_token(self, seqid, iprot, oprot):
        args = get_delegation_token_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_delegation_token_result()
        try:
            result.success = self._handler.get_delegation_token(args.token_owner, args.renewer_kerberos_principal_name)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_delegation_token", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_renew_delegation_token(self, seqid, iprot, oprot):
        args = renew_delegation_token_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = renew_delegation_token_result()
        try:
            result.success = self._handler.renew_delegation_token(args.token_str_form)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("renew_delegation_token", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_cancel_delegation_token(self, seqid, iprot, oprot):
        args = cancel_delegation_token_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = cancel_delegation_token_result()
        try:
            self._handler.cancel_delegation_token(args.token_str_form)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except MetaException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("cancel_delegation_token", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_open_txns(self, seqid, iprot, oprot):
        args = get_open_txns_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_open_txns_result()
        try:
            result.success = self._handler.get_open_txns()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_open_txns", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_open_txns_info(self, seqid, iprot, oprot):
        args = get_open_txns_info_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_open_txns_info_result()
        try:
            result.success = self._handler.get_open_txns_info()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_open_txns_info", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_open_txns(self, seqid, iprot, oprot):
        args = open_txns_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = open_txns_result()
        try:
            result.success = self._handler.open_txns(args.rqst)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("open_txns", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_abort_txn(self, seqid, iprot, oprot):
        args = abort_txn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = abort_txn_result()
        try:
            self._handler.abort_txn(args.rqst)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("abort_txn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_commit_txn(self, seqid, iprot, oprot):
        args = commit_txn_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = commit_txn_result()
        try:
            self._handler.commit_txn(args.rqst)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TxnAbortedException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("commit_txn", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_lock(self, seqid, iprot, oprot):
        args = lock_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = lock_result()
        try:
            result.success = self._handler.lock(args.rqst)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TxnAbortedException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("lock", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_check_lock(self, seqid, iprot, oprot):
        args = check_lock_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = check_lock_result()
        try:
            result.success = self._handler.check_lock(args.rqst)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchTxnException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TxnAbortedException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except NoSuchLockException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("check_lock", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_unlock(self, seqid, iprot, oprot):
        args = unlock_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = unlock_result()
        try:
            self._handler.unlock(args.rqst)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchLockException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except TxnOpenException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("unlock", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_show_locks(self, seqid, iprot, oprot):
        args = show_locks_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = show_locks_result()
        try:
            result.success = self._handler.show_locks(args.rqst)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("show_locks", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_heartbeat(self, seqid, iprot, oprot):
        args = heartbeat_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = heartbeat_result()
        try:
            self._handler.heartbeat(args.ids)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except NoSuchLockException as o1:
            msg_type = TMessageType.REPLY
            result.o1 = o1
        except NoSuchTxnException as o2:
            msg_type = TMessageType.REPLY
            result.o2 = o2
        except TxnAbortedException as o3:
            msg_type = TMessageType.REPLY
            result.o3 = o3
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("heartbeat", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_heartbeat_txn_range(self, seqid, iprot, oprot):
        args = heartbeat_txn_range_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = heartbeat_txn_range_result()
        try:
            result.success = self._handler.heartbeat_txn_range(args.txns)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("heartbeat_txn_range", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_compact(self, seqid, iprot, oprot):
        args = compact_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = compact_result()
        try:
            self._handler.compact(args.rqst)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("compact", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_show_compact(self, seqid, iprot, oprot):
        args = show_compact_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = show_compact_result()
        try:
            result.success = self._handler.show_compact(args.rqst)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("show_compact", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_next_notification(self, seqid, iprot, oprot):
        args = get_next_notification_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_next_notification_result()
        try:
            result.success = self._handler.get_next_notification(args.rqst)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_next_notification", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_get_current_notificationEventId(self, seqid, iprot, oprot):
        args = get_current_notificationEventId_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = get_current_notificationEventId_result()
        try:
            result.success = self._handler.get_current_notificationEventId()
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("get_current_notificationEventId", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

    def process_fire_listener_event(self, seqid, iprot, oprot):
        args = fire_listener_event_args()
        args.read(iprot)
        iprot.readMessageEnd()
        result = fire_listener_event_result()
        try:
            result.success = self._handler.fire_listener_event(args.rqst)
            msg_type = TMessageType.REPLY
        except (TTransport.TTransportException, KeyboardInterrupt, SystemExit):
            raise
        except Exception as ex:
            msg_type = TMessageType.EXCEPTION
            logging.exception(ex)
            result = TApplicationException(TApplicationException.INTERNAL_ERROR, 'Internal error')
        oprot.writeMessageBegin("fire_listener_event", msg_type, seqid)
        result.write(oprot)
        oprot.writeMessageEnd()
        oprot.trans.flush()

# HELPER FUNCTIONS AND STRUCTURES


class getMetaConf_args(object):
    """
    Attributes:
     - key
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
    )

    def __init__(self, key=None,):
        self.key = key

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getMetaConf_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class getMetaConf_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('getMetaConf_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class setMetaConf_args(object):
    """
    Attributes:
     - key
     - value
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'key', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'value', 'UTF8', None, ),  # 2
    )

    def __init__(self, key=None, value=None,):
        self.key = key
        self.value = value

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.key = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.value = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('setMetaConf_args')
        if self.key is not None:
            oprot.writeFieldBegin('key', TType.STRING, 1)
            oprot.writeString(self.key.encode('utf-8') if sys.version_info[0] == 2 else self.key)
            oprot.writeFieldEnd()
        if self.value is not None:
            oprot.writeFieldBegin('value', TType.STRING, 2)
            oprot.writeString(self.value.encode('utf-8') if sys.version_info[0] == 2 else self.value)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class setMetaConf_result(object):
    """
    Attributes:
     - o1
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, o1=None,):
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('setMetaConf_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class create_database_args(object):
    """
    Attributes:
     - database
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'database', (Database, Database.thrift_spec), None, ),  # 1
    )

    def __init__(self, database=None,):
        self.database = database

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.database = Database()
                    self.database.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('create_database_args')
        if self.database is not None:
            oprot.writeFieldBegin('database', TType.STRUCT, 1)
            self.database.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class create_database_result(object):
    """
    Attributes:
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
    )

    def __init__(self, o1=None, o2=None, o3=None,):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('create_database_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_database_args(object):
    """
    Attributes:
     - name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    )

    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_database_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_database_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Database, Database.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Database()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_database_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_database_args(object):
    """
    Attributes:
     - name
     - deleteData
     - cascade
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
        (2, TType.BOOL, 'deleteData', None, None, ),  # 2
        (3, TType.BOOL, 'cascade', None, None, ),  # 3
    )

    def __init__(self, name=None, deleteData=None, cascade=None,):
        self.name = name
        self.deleteData = deleteData
        self.cascade = cascade

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.cascade = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_database_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 2)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        if self.cascade is not None:
            oprot.writeFieldBegin('cascade', TType.BOOL, 3)
            oprot.writeBool(self.cascade)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_database_result(object):
    """
    Attributes:
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
    )

    def __init__(self, o1=None, o2=None, o3=None,):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_database_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_databases_args(object):
    """
    Attributes:
     - pattern
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'pattern', 'UTF8', None, ),  # 1
    )

    def __init__(self, pattern=None,):
        self.pattern = pattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_databases_args')
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 1)
            oprot.writeString(self.pattern.encode('utf-8') if sys.version_info[0] == 2 else self.pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_databases_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype465, _size462) = iprot.readListBegin()
                    for _i466 in range(_size462):
                        _elem467 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem467)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_databases_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter468 in self.success:
                oprot.writeString(iter468.encode('utf-8') if sys.version_info[0] == 2 else iter468)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_all_databases_args(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_all_databases_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_all_databases_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype472, _size469) = iprot.readListBegin()
                    for _i473 in range(_size469):
                        _elem474 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem474)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_all_databases_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter475 in self.success:
                oprot.writeString(iter475.encode('utf-8') if sys.version_info[0] == 2 else iter475)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_database_args(object):
    """
    Attributes:
     - dbname
     - db
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
        (2, TType.STRUCT, 'db', (Database, Database.thrift_spec), None, ),  # 2
    )

    def __init__(self, dbname=None, db=None,):
        self.dbname = dbname
        self.db = db

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.db = Database()
                    self.db.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_database_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.db is not None:
            oprot.writeFieldBegin('db', TType.STRUCT, 2)
            self.db.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_database_result(object):
    """
    Attributes:
     - o1
     - o2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
    )

    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_database_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_type_args(object):
    """
    Attributes:
     - name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    )

    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_type_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_type_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Type, Type.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Type()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class create_type_args(object):
    """
    Attributes:
     - type
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'type', (Type, Type.thrift_spec), None, ),  # 1
    )

    def __init__(self, type=None,):
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.type = Type()
                    self.type.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('create_type_args')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRUCT, 1)
            self.type.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class create_type_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('create_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_type_args(object):
    """
    Attributes:
     - type
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'type', 'UTF8', None, ),  # 1
    )

    def __init__(self, type=None,):
        self.type = type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.type = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_type_args')
        if self.type is not None:
            oprot.writeFieldBegin('type', TType.STRING, 1)
            oprot.writeString(self.type.encode('utf-8') if sys.version_info[0] == 2 else self.type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_type_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_type_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_type_all_args(object):
    """
    Attributes:
     - name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
    )

    def __init__(self, name=None,):
        self.name = name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_type_all_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_type_all_result(object):
    """
    Attributes:
     - success
     - o2
    """

    thrift_spec = (
        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRUCT, (Type, Type.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o2=None,):
        self.success = success
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype477, _vtype478, _size476) = iprot.readMapBegin()
                    for _i480 in range(_size476):
                        _key481 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val482 = Type()
                        _val482.read(iprot)
                        self.success[_key481] = _val482
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_type_all_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRUCT, len(self.success))
            for kiter483, viter484 in self.success.items():
                oprot.writeString(kiter483.encode('utf-8') if sys.version_info[0] == 2 else kiter483)
                viter484.write(oprot)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 1)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_fields_args(object):
    """
    Attributes:
     - db_name
     - table_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    )

    def __init__(self, db_name=None, table_name=None,):
        self.db_name = db_name
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_fields_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_fields_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (FieldSchema, FieldSchema.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype488, _size485) = iprot.readListBegin()
                    for _i489 in range(_size485):
                        _elem490 = FieldSchema()
                        _elem490.read(iprot)
                        self.success.append(_elem490)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = UnknownTableException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_fields_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter491 in self.success:
                iter491.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_fields_with_environment_context_args(object):
    """
    Attributes:
     - db_name
     - table_name
     - environment_context
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
        (3, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ),  # 3
    )

    def __init__(self, db_name=None, table_name=None, environment_context=None,):
        self.db_name = db_name
        self.table_name = table_name
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_fields_with_environment_context_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 3)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_fields_with_environment_context_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (FieldSchema, FieldSchema.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype495, _size492) = iprot.readListBegin()
                    for _i496 in range(_size492):
                        _elem497 = FieldSchema()
                        _elem497.read(iprot)
                        self.success.append(_elem497)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = UnknownTableException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_fields_with_environment_context_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter498 in self.success:
                iter498.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_schema_args(object):
    """
    Attributes:
     - db_name
     - table_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
    )

    def __init__(self, db_name=None, table_name=None,):
        self.db_name = db_name
        self.table_name = table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_schema_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_schema_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (FieldSchema, FieldSchema.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype502, _size499) = iprot.readListBegin()
                    for _i503 in range(_size499):
                        _elem504 = FieldSchema()
                        _elem504.read(iprot)
                        self.success.append(_elem504)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = UnknownTableException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_schema_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter505 in self.success:
                iter505.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_schema_with_environment_context_args(object):
    """
    Attributes:
     - db_name
     - table_name
     - environment_context
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'table_name', 'UTF8', None, ),  # 2
        (3, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ),  # 3
    )

    def __init__(self, db_name=None, table_name=None, environment_context=None,):
        self.db_name = db_name
        self.table_name = table_name
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.table_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_schema_with_environment_context_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.table_name is not None:
            oprot.writeFieldBegin('table_name', TType.STRING, 2)
            oprot.writeString(self.table_name.encode('utf-8') if sys.version_info[0] == 2 else self.table_name)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 3)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_schema_with_environment_context_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (FieldSchema, FieldSchema.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (UnknownTableException, UnknownTableException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype509, _size506) = iprot.readListBegin()
                    for _i510 in range(_size506):
                        _elem511 = FieldSchema()
                        _elem511.read(iprot)
                        self.success.append(_elem511)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = UnknownTableException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_schema_with_environment_context_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter512 in self.success:
                iter512.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class create_table_args(object):
    """
    Attributes:
     - tbl
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'tbl', (Table, Table.thrift_spec), None, ),  # 1
    )

    def __init__(self, tbl=None,):
        self.tbl = tbl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tbl = Table()
                    self.tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('create_table_args')
        if self.tbl is not None:
            oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
            self.tbl.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class create_table_result(object):
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'o4', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 4
    )

    def __init__(self, o1=None, o2=None, o3=None, o4=None,):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = NoSuchObjectException()
                    self.o4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('create_table_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class create_table_with_environment_context_args(object):
    """
    Attributes:
     - tbl
     - environment_context
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'tbl', (Table, Table.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ),  # 2
    )

    def __init__(self, tbl=None, environment_context=None,):
        self.tbl = tbl
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.tbl = Table()
                    self.tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('create_table_with_environment_context_args')
        if self.tbl is not None:
            oprot.writeFieldBegin('tbl', TType.STRUCT, 1)
            self.tbl.write(oprot)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 2)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class create_table_with_environment_context_result(object):
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'o4', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 4
    )

    def __init__(self, o1=None, o2=None, o3=None, o4=None,):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = NoSuchObjectException()
                    self.o4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('create_table_with_environment_context_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_table_args(object):
    """
    Attributes:
     - dbname
     - name
     - deleteData
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
        (3, TType.BOOL, 'deleteData', None, None, ),  # 3
    )

    def __init__(self, dbname=None, name=None, deleteData=None,):
        self.dbname = dbname
        self.name = name
        self.deleteData = deleteData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_table_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 3)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_table_result(object):
    """
    Attributes:
     - o1
     - o3
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, o1=None, o3=None,):
        self.o1 = o1
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_table_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 2)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_table_with_environment_context_args(object):
    """
    Attributes:
     - dbname
     - name
     - deleteData
     - environment_context
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'name', 'UTF8', None, ),  # 2
        (3, TType.BOOL, 'deleteData', None, None, ),  # 3
        (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ),  # 4
    )

    def __init__(self, dbname=None, name=None, deleteData=None, environment_context=None,):
        self.dbname = dbname
        self.name = name
        self.deleteData = deleteData
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_table_with_environment_context_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 2)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 3)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_table_with_environment_context_result(object):
    """
    Attributes:
     - o1
     - o3
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, o1=None, o3=None,):
        self.o1 = o1
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_table_with_environment_context_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 2)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_tables_args(object):
    """
    Attributes:
     - db_name
     - pattern
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'pattern', 'UTF8', None, ),  # 2
    )

    def __init__(self, db_name=None, pattern=None,):
        self.db_name = db_name
        self.pattern = pattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_tables_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 2)
            oprot.writeString(self.pattern.encode('utf-8') if sys.version_info[0] == 2 else self.pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_tables_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype516, _size513) = iprot.readListBegin()
                    for _i517 in range(_size513):
                        _elem518 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem518)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_tables_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter519 in self.success:
                oprot.writeString(iter519.encode('utf-8') if sys.version_info[0] == 2 else iter519)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_table_meta_args(object):
    """
    Attributes:
     - db_patterns
     - tbl_patterns
     - tbl_types
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_patterns', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_patterns', 'UTF8', None, ),  # 2
        (3, TType.LIST, 'tbl_types', (TType.STRING, 'UTF8', False), None, ),  # 3
    )

    def __init__(self, db_patterns=None, tbl_patterns=None, tbl_types=None,):
        self.db_patterns = db_patterns
        self.tbl_patterns = tbl_patterns
        self.tbl_types = tbl_types

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_patterns = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_patterns = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.tbl_types = []
                    (_etype523, _size520) = iprot.readListBegin()
                    for _i524 in range(_size520):
                        _elem525 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.tbl_types.append(_elem525)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_table_meta_args')
        if self.db_patterns is not None:
            oprot.writeFieldBegin('db_patterns', TType.STRING, 1)
            oprot.writeString(self.db_patterns.encode('utf-8') if sys.version_info[0] == 2 else self.db_patterns)
            oprot.writeFieldEnd()
        if self.tbl_patterns is not None:
            oprot.writeFieldBegin('tbl_patterns', TType.STRING, 2)
            oprot.writeString(self.tbl_patterns.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_patterns)
            oprot.writeFieldEnd()
        if self.tbl_types is not None:
            oprot.writeFieldBegin('tbl_types', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.tbl_types))
            for iter526 in self.tbl_types:
                oprot.writeString(iter526.encode('utf-8') if sys.version_info[0] == 2 else iter526)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_table_meta_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (TableMeta, TableMeta.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype530, _size527) = iprot.readListBegin()
                    for _i531 in range(_size527):
                        _elem532 = TableMeta()
                        _elem532.read(iprot)
                        self.success.append(_elem532)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_table_meta_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter533 in self.success:
                iter533.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_all_tables_args(object):
    """
    Attributes:
     - db_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
    )

    def __init__(self, db_name=None,):
        self.db_name = db_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_all_tables_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_all_tables_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype537, _size534) = iprot.readListBegin()
                    for _i538 in range(_size534):
                        _elem539 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem539)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_all_tables_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter540 in self.success:
                oprot.writeString(iter540.encode('utf-8') if sys.version_info[0] == 2 else iter540)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_table_args(object):
    """
    Attributes:
     - dbname
     - tbl_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
    )

    def __init__(self, dbname=None, tbl_name=None,):
        self.dbname = dbname
        self.tbl_name = tbl_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_table_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_table_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Table, Table.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Table()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_table_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_table_objects_by_name_args(object):
    """
    Attributes:
     - dbname
     - tbl_names
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
        (2, TType.LIST, 'tbl_names', (TType.STRING, 'UTF8', False), None, ),  # 2
    )

    def __init__(self, dbname=None, tbl_names=None,):
        self.dbname = dbname
        self.tbl_names = tbl_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.tbl_names = []
                    (_etype544, _size541) = iprot.readListBegin()
                    for _i545 in range(_size541):
                        _elem546 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.tbl_names.append(_elem546)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_table_objects_by_name_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_names is not None:
            oprot.writeFieldBegin('tbl_names', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.tbl_names))
            for iter547 in self.tbl_names:
                oprot.writeString(iter547.encode('utf-8') if sys.version_info[0] == 2 else iter547)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_table_objects_by_name_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (Table, Table.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype551, _size548) = iprot.readListBegin()
                    for _i552 in range(_size548):
                        _elem553 = Table()
                        _elem553.read(iprot)
                        self.success.append(_elem553)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_table_objects_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter554 in self.success:
                iter554.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_table_names_by_filter_args(object):
    """
    Attributes:
     - dbname
     - filter
     - max_tables
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'filter', 'UTF8', None, ),  # 2
        (3, TType.I16, 'max_tables', None, -1, ),  # 3
    )

    def __init__(self, dbname=None, filter=None, max_tables=thrift_spec[3][4],):
        self.dbname = dbname
        self.filter = filter
        self.max_tables = max_tables

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.filter = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_tables = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_table_names_by_filter_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRING, 2)
            oprot.writeString(self.filter.encode('utf-8') if sys.version_info[0] == 2 else self.filter)
            oprot.writeFieldEnd()
        if self.max_tables is not None:
            oprot.writeFieldBegin('max_tables', TType.I16, 3)
            oprot.writeI16(self.max_tables)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_table_names_by_filter_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype558, _size555) = iprot.readListBegin()
                    for _i559 in range(_size555):
                        _elem560 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem560)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidOperationException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_table_names_by_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter561 in self.success:
                oprot.writeString(iter561.encode('utf-8') if sys.version_info[0] == 2 else iter561)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_table_args(object):
    """
    Attributes:
     - dbname
     - tbl_name
     - new_tbl
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRUCT, 'new_tbl', (Table, Table.thrift_spec), None, ),  # 3
    )

    def __init__(self, dbname=None, tbl_name=None, new_tbl=None,):
        self.dbname = dbname
        self.tbl_name = tbl_name
        self.new_tbl = new_tbl

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.new_tbl = Table()
                    self.new_tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_table_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_tbl is not None:
            oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
            self.new_tbl.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_table_result(object):
    """
    Attributes:
     - o1
     - o2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_table_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_table_with_environment_context_args(object):
    """
    Attributes:
     - dbname
     - tbl_name
     - new_tbl
     - environment_context
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRUCT, 'new_tbl', (Table, Table.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ),  # 4
    )

    def __init__(self, dbname=None, tbl_name=None, new_tbl=None, environment_context=None,):
        self.dbname = dbname
        self.tbl_name = tbl_name
        self.new_tbl = new_tbl
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.new_tbl = Table()
                    self.new_tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_table_with_environment_context_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_tbl is not None:
            oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
            self.new_tbl.write(oprot)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_table_with_environment_context_result(object):
    """
    Attributes:
     - o1
     - o2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_table_with_environment_context_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_table_with_cascade_args(object):
    """
    Attributes:
     - dbname
     - tbl_name
     - new_tbl
     - cascade
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRUCT, 'new_tbl', (Table, Table.thrift_spec), None, ),  # 3
        (4, TType.BOOL, 'cascade', None, None, ),  # 4
    )

    def __init__(self, dbname=None, tbl_name=None, new_tbl=None, cascade=None,):
        self.dbname = dbname
        self.tbl_name = tbl_name
        self.new_tbl = new_tbl
        self.cascade = cascade

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.new_tbl = Table()
                    self.new_tbl.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.cascade = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_table_with_cascade_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_tbl is not None:
            oprot.writeFieldBegin('new_tbl', TType.STRUCT, 3)
            self.new_tbl.write(oprot)
            oprot.writeFieldEnd()
        if self.cascade is not None:
            oprot.writeFieldBegin('cascade', TType.BOOL, 4)
            oprot.writeBool(self.cascade)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_table_with_cascade_result(object):
    """
    Attributes:
     - o1
     - o2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_table_with_cascade_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class add_partition_args(object):
    """
    Attributes:
     - new_part
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ),  # 1
    )

    def __init__(self, new_part=None,):
        self.new_part = new_part

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.new_part = Partition()
                    self.new_part.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('add_partition_args')
        if self.new_part is not None:
            oprot.writeFieldBegin('new_part', TType.STRUCT, 1)
            self.new_part.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class add_partition_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('add_partition_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class add_partition_with_environment_context_args(object):
    """
    Attributes:
     - new_part
     - environment_context
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ),  # 2
    )

    def __init__(self, new_part=None, environment_context=None,):
        self.new_part = new_part
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.new_part = Partition()
                    self.new_part.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('add_partition_with_environment_context_args')
        if self.new_part is not None:
            oprot.writeFieldBegin('new_part', TType.STRUCT, 1)
            self.new_part.write(oprot)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 2)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class add_partition_with_environment_context_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('add_partition_with_environment_context_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class add_partitions_args(object):
    """
    Attributes:
     - new_parts
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'new_parts', (TType.STRUCT, (Partition, Partition.thrift_spec), False), None, ),  # 1
    )

    def __init__(self, new_parts=None,):
        self.new_parts = new_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.new_parts = []
                    (_etype565, _size562) = iprot.readListBegin()
                    for _i566 in range(_size562):
                        _elem567 = Partition()
                        _elem567.read(iprot)
                        self.new_parts.append(_elem567)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('add_partitions_args')
        if self.new_parts is not None:
            oprot.writeFieldBegin('new_parts', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
            for iter568 in self.new_parts:
                iter568.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class add_partitions_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('add_partitions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class add_partitions_pspec_args(object):
    """
    Attributes:
     - new_parts
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'new_parts', (TType.STRUCT, (PartitionSpec, PartitionSpec.thrift_spec), False), None, ),  # 1
    )

    def __init__(self, new_parts=None,):
        self.new_parts = new_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.new_parts = []
                    (_etype572, _size569) = iprot.readListBegin()
                    for _i573 in range(_size569):
                        _elem574 = PartitionSpec()
                        _elem574.read(iprot)
                        self.new_parts.append(_elem574)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('add_partitions_pspec_args')
        if self.new_parts is not None:
            oprot.writeFieldBegin('new_parts', TType.LIST, 1)
            oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
            for iter575 in self.new_parts:
                iter575.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class add_partitions_pspec_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.I32, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I32:
                    self.success = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('add_partitions_pspec_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I32, 0)
            oprot.writeI32(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class append_partition_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
    )

    def __init__(self, db_name=None, tbl_name=None, part_vals=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype579, _size576) = iprot.readListBegin()
                    for _i580 in range(_size576):
                        _elem581 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem581)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('append_partition_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter582 in self.part_vals:
                oprot.writeString(iter582.encode('utf-8') if sys.version_info[0] == 2 else iter582)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class append_partition_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('append_partition_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class add_partitions_req_args(object):
    """
    Attributes:
     - request
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'request', (AddPartitionsRequest, AddPartitionsRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = AddPartitionsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('add_partitions_req_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class add_partitions_req_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (AddPartitionsResult, AddPartitionsResult.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AddPartitionsResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('add_partitions_req_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class append_partition_with_environment_context_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - environment_context
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
        (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ),  # 4
    )

    def __init__(self, db_name=None, tbl_name=None, part_vals=None, environment_context=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype586, _size583) = iprot.readListBegin()
                    for _i587 in range(_size583):
                        _elem588 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem588)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('append_partition_with_environment_context_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter589 in self.part_vals:
                oprot.writeString(iter589.encode('utf-8') if sys.version_info[0] == 2 else iter589)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class append_partition_with_environment_context_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('append_partition_with_environment_context_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class append_partition_by_name_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'part_name', 'UTF8', None, ),  # 3
    )

    def __init__(self, db_name=None, tbl_name=None, part_name=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('append_partition_by_name_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 3)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class append_partition_by_name_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('append_partition_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class append_partition_by_name_with_environment_context_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
     - environment_context
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'part_name', 'UTF8', None, ),  # 3
        (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ),  # 4
    )

    def __init__(self, db_name=None, tbl_name=None, part_name=None, environment_context=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('append_partition_by_name_with_environment_context_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 3)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class append_partition_by_name_with_environment_context_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('append_partition_by_name_with_environment_context_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_partition_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
        (4, TType.BOOL, 'deleteData', None, None, ),  # 4
    )

    def __init__(self, db_name=None, tbl_name=None, part_vals=None, deleteData=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.deleteData = deleteData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype593, _size590) = iprot.readListBegin()
                    for _i594 in range(_size590):
                        _elem595 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem595)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_partition_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter596 in self.part_vals:
                oprot.writeString(iter596.encode('utf-8') if sys.version_info[0] == 2 else iter596)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_partition_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_partition_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_partition_with_environment_context_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - deleteData
     - environment_context
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
        (4, TType.BOOL, 'deleteData', None, None, ),  # 4
        (5, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ),  # 5
    )

    def __init__(self, db_name=None, tbl_name=None, part_vals=None, deleteData=None, environment_context=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.deleteData = deleteData
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype600, _size597) = iprot.readListBegin()
                    for _i601 in range(_size597):
                        _elem602 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem602)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_partition_with_environment_context_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter603 in self.part_vals:
                oprot.writeString(iter603.encode('utf-8') if sys.version_info[0] == 2 else iter603)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 5)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_partition_with_environment_context_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_partition_with_environment_context_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_partition_by_name_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
     - deleteData
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'part_name', 'UTF8', None, ),  # 3
        (4, TType.BOOL, 'deleteData', None, None, ),  # 4
    )

    def __init__(self, db_name=None, tbl_name=None, part_name=None, deleteData=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name
        self.deleteData = deleteData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_partition_by_name_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 3)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_partition_by_name_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_partition_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_partition_by_name_with_environment_context_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
     - deleteData
     - environment_context
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'part_name', 'UTF8', None, ),  # 3
        (4, TType.BOOL, 'deleteData', None, None, ),  # 4
        (5, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ),  # 5
    )

    def __init__(self, db_name=None, tbl_name=None, part_name=None, deleteData=None, environment_context=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name
        self.deleteData = deleteData
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_partition_by_name_with_environment_context_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 3)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 5)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_partition_by_name_with_environment_context_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_partition_by_name_with_environment_context_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_partitions_req_args(object):
    """
    Attributes:
     - req
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'req', (DropPartitionsRequest, DropPartitionsRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = DropPartitionsRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_partitions_req_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_partitions_req_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (DropPartitionsResult, DropPartitionsResult.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = DropPartitionsResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_partitions_req_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partition_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
    )

    def __init__(self, db_name=None, tbl_name=None, part_vals=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype607, _size604) = iprot.readListBegin()
                    for _i608 in range(_size604):
                        _elem609 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem609)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partition_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter610 in self.part_vals:
                oprot.writeString(iter610.encode('utf-8') if sys.version_info[0] == 2 else iter610)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partition_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partition_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class exchange_partition_args(object):
    """
    Attributes:
     - partitionSpecs
     - source_db
     - source_table_name
     - dest_db
     - dest_table_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.MAP, 'partitionSpecs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
        (2, TType.STRING, 'source_db', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'source_table_name', 'UTF8', None, ),  # 3
        (4, TType.STRING, 'dest_db', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'dest_table_name', 'UTF8', None, ),  # 5
    )

    def __init__(self, partitionSpecs=None, source_db=None, source_table_name=None, dest_db=None, dest_table_name=None,):
        self.partitionSpecs = partitionSpecs
        self.source_db = source_db
        self.source_table_name = source_table_name
        self.dest_db = dest_db
        self.dest_table_name = dest_table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.partitionSpecs = {}
                    (_ktype612, _vtype613, _size611) = iprot.readMapBegin()
                    for _i615 in range(_size611):
                        _key616 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val617 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.partitionSpecs[_key616] = _val617
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.source_db = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.source_table_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dest_db = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.dest_table_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('exchange_partition_args')
        if self.partitionSpecs is not None:
            oprot.writeFieldBegin('partitionSpecs', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.partitionSpecs))
            for kiter618, viter619 in self.partitionSpecs.items():
                oprot.writeString(kiter618.encode('utf-8') if sys.version_info[0] == 2 else kiter618)
                oprot.writeString(viter619.encode('utf-8') if sys.version_info[0] == 2 else viter619)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.source_db is not None:
            oprot.writeFieldBegin('source_db', TType.STRING, 2)
            oprot.writeString(self.source_db.encode('utf-8') if sys.version_info[0] == 2 else self.source_db)
            oprot.writeFieldEnd()
        if self.source_table_name is not None:
            oprot.writeFieldBegin('source_table_name', TType.STRING, 3)
            oprot.writeString(self.source_table_name.encode('utf-8') if sys.version_info[0] == 2 else self.source_table_name)
            oprot.writeFieldEnd()
        if self.dest_db is not None:
            oprot.writeFieldBegin('dest_db', TType.STRING, 4)
            oprot.writeString(self.dest_db.encode('utf-8') if sys.version_info[0] == 2 else self.dest_db)
            oprot.writeFieldEnd()
        if self.dest_table_name is not None:
            oprot.writeFieldBegin('dest_table_name', TType.STRING, 5)
            oprot.writeString(self.dest_table_name.encode('utf-8') if sys.version_info[0] == 2 else self.dest_table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class exchange_partition_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ),  # 4
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException()
                    self.o4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('exchange_partition_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class exchange_partitions_args(object):
    """
    Attributes:
     - partitionSpecs
     - source_db
     - source_table_name
     - dest_db
     - dest_table_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.MAP, 'partitionSpecs', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 1
        (2, TType.STRING, 'source_db', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'source_table_name', 'UTF8', None, ),  # 3
        (4, TType.STRING, 'dest_db', 'UTF8', None, ),  # 4
        (5, TType.STRING, 'dest_table_name', 'UTF8', None, ),  # 5
    )

    def __init__(self, partitionSpecs=None, source_db=None, source_table_name=None, dest_db=None, dest_table_name=None,):
        self.partitionSpecs = partitionSpecs
        self.source_db = source_db
        self.source_table_name = source_table_name
        self.dest_db = dest_db
        self.dest_table_name = dest_table_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.MAP:
                    self.partitionSpecs = {}
                    (_ktype621, _vtype622, _size620) = iprot.readMapBegin()
                    for _i624 in range(_size620):
                        _key625 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val626 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.partitionSpecs[_key625] = _val626
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.source_db = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.source_table_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.dest_db = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.dest_table_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('exchange_partitions_args')
        if self.partitionSpecs is not None:
            oprot.writeFieldBegin('partitionSpecs', TType.MAP, 1)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.partitionSpecs))
            for kiter627, viter628 in self.partitionSpecs.items():
                oprot.writeString(kiter627.encode('utf-8') if sys.version_info[0] == 2 else kiter627)
                oprot.writeString(viter628.encode('utf-8') if sys.version_info[0] == 2 else viter628)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.source_db is not None:
            oprot.writeFieldBegin('source_db', TType.STRING, 2)
            oprot.writeString(self.source_db.encode('utf-8') if sys.version_info[0] == 2 else self.source_db)
            oprot.writeFieldEnd()
        if self.source_table_name is not None:
            oprot.writeFieldBegin('source_table_name', TType.STRING, 3)
            oprot.writeString(self.source_table_name.encode('utf-8') if sys.version_info[0] == 2 else self.source_table_name)
            oprot.writeFieldEnd()
        if self.dest_db is not None:
            oprot.writeFieldBegin('dest_db', TType.STRING, 4)
            oprot.writeString(self.dest_db.encode('utf-8') if sys.version_info[0] == 2 else self.dest_db)
            oprot.writeFieldEnd()
        if self.dest_table_name is not None:
            oprot.writeFieldBegin('dest_table_name', TType.STRING, 5)
            oprot.writeString(self.dest_table_name.encode('utf-8') if sys.version_info[0] == 2 else self.dest_table_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class exchange_partitions_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (Partition, Partition.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ),  # 4
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype632, _size629) = iprot.readListBegin()
                    for _i633 in range(_size629):
                        _elem634 = Partition()
                        _elem634.read(iprot)
                        self.success.append(_elem634)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException()
                    self.o4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('exchange_partitions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter635 in self.success:
                iter635.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partition_with_auth_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - user_name
     - group_names
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
        (4, TType.STRING, 'user_name', 'UTF8', None, ),  # 4
        (5, TType.LIST, 'group_names', (TType.STRING, 'UTF8', False), None, ),  # 5
    )

    def __init__(self, db_name=None, tbl_name=None, part_vals=None, user_name=None, group_names=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.user_name = user_name
        self.group_names = group_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype639, _size636) = iprot.readListBegin()
                    for _i640 in range(_size636):
                        _elem641 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem641)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.user_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype645, _size642) = iprot.readListBegin()
                    for _i646 in range(_size642):
                        _elem647 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.group_names.append(_elem647)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partition_with_auth_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter648 in self.part_vals:
                oprot.writeString(iter648.encode('utf-8') if sys.version_info[0] == 2 else iter648)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.user_name is not None:
            oprot.writeFieldBegin('user_name', TType.STRING, 4)
            oprot.writeString(self.user_name.encode('utf-8') if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin('group_names', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter649 in self.group_names:
                oprot.writeString(iter649.encode('utf-8') if sys.version_info[0] == 2 else iter649)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partition_with_auth_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partition_with_auth_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partition_by_name_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'part_name', 'UTF8', None, ),  # 3
    )

    def __init__(self, db_name=None, tbl_name=None, part_name=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partition_by_name_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 3)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partition_by_name_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Partition, Partition.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Partition()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partition_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - max_parts
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.I16, 'max_parts', None, -1, ),  # 3
    )

    def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4],):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_parts = max_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I16, 3)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (Partition, Partition.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype653, _size650) = iprot.readListBegin()
                    for _i654 in range(_size650):
                        _elem655 = Partition()
                        _elem655.read(iprot)
                        self.success.append(_elem655)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter656 in self.success:
                iter656.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_with_auth_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - max_parts
     - user_name
     - group_names
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.I16, 'max_parts', None, -1, ),  # 3
        (4, TType.STRING, 'user_name', 'UTF8', None, ),  # 4
        (5, TType.LIST, 'group_names', (TType.STRING, 'UTF8', False), None, ),  # 5
    )

    def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4], user_name=None, group_names=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_parts = max_parts
        self.user_name = user_name
        self.group_names = group_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.user_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype660, _size657) = iprot.readListBegin()
                    for _i661 in range(_size657):
                        _elem662 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.group_names.append(_elem662)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_with_auth_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I16, 3)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        if self.user_name is not None:
            oprot.writeFieldBegin('user_name', TType.STRING, 4)
            oprot.writeString(self.user_name.encode('utf-8') if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin('group_names', TType.LIST, 5)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter663 in self.group_names:
                oprot.writeString(iter663.encode('utf-8') if sys.version_info[0] == 2 else iter663)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_with_auth_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (Partition, Partition.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype667, _size664) = iprot.readListBegin()
                    for _i668 in range(_size664):
                        _elem669 = Partition()
                        _elem669.read(iprot)
                        self.success.append(_elem669)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_with_auth_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter670 in self.success:
                iter670.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_pspec_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - max_parts
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.I32, 'max_parts', None, -1, ),  # 3
    )

    def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4],):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_parts = max_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.max_parts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_pspec_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I32, 3)
            oprot.writeI32(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_pspec_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (PartitionSpec, PartitionSpec.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype674, _size671) = iprot.readListBegin()
                    for _i675 in range(_size671):
                        _elem676 = PartitionSpec()
                        _elem676.read(iprot)
                        self.success.append(_elem676)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_pspec_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter677 in self.success:
                iter677.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partition_names_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - max_parts
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.I16, 'max_parts', None, -1, ),  # 3
    )

    def __init__(self, db_name=None, tbl_name=None, max_parts=thrift_spec[3][4],):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_parts = max_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partition_names_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I16, 3)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partition_names_result(object):
    """
    Attributes:
     - success
     - o2
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o2=None,):
        self.success = success
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype681, _size678) = iprot.readListBegin()
                    for _i682 in range(_size678):
                        _elem683 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem683)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partition_names_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter684 in self.success:
                oprot.writeString(iter684.encode('utf-8') if sys.version_info[0] == 2 else iter684)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 1)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_ps_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
        (4, TType.I16, 'max_parts', None, -1, ),  # 4
    )

    def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4],):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.max_parts = max_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype688, _size685) = iprot.readListBegin()
                    for _i689 in range(_size685):
                        _elem690 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem690)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_ps_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter691 in self.part_vals:
                oprot.writeString(iter691.encode('utf-8') if sys.version_info[0] == 2 else iter691)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I16, 4)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_ps_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (Partition, Partition.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype695, _size692) = iprot.readListBegin()
                    for _i696 in range(_size692):
                        _elem697 = Partition()
                        _elem697.read(iprot)
                        self.success.append(_elem697)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_ps_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter698 in self.success:
                iter698.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_ps_with_auth_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
     - user_name
     - group_names
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
        (4, TType.I16, 'max_parts', None, -1, ),  # 4
        (5, TType.STRING, 'user_name', 'UTF8', None, ),  # 5
        (6, TType.LIST, 'group_names', (TType.STRING, 'UTF8', False), None, ),  # 6
    )

    def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4], user_name=None, group_names=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.max_parts = max_parts
        self.user_name = user_name
        self.group_names = group_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype702, _size699) = iprot.readListBegin()
                    for _i703 in range(_size699):
                        _elem704 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem704)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRING:
                    self.user_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype708, _size705) = iprot.readListBegin()
                    for _i709 in range(_size705):
                        _elem710 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.group_names.append(_elem710)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_ps_with_auth_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter711 in self.part_vals:
                oprot.writeString(iter711.encode('utf-8') if sys.version_info[0] == 2 else iter711)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I16, 4)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        if self.user_name is not None:
            oprot.writeFieldBegin('user_name', TType.STRING, 5)
            oprot.writeString(self.user_name.encode('utf-8') if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin('group_names', TType.LIST, 6)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter712 in self.group_names:
                oprot.writeString(iter712.encode('utf-8') if sys.version_info[0] == 2 else iter712)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_ps_with_auth_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (Partition, Partition.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype716, _size713) = iprot.readListBegin()
                    for _i717 in range(_size713):
                        _elem718 = Partition()
                        _elem718.read(iprot)
                        self.success.append(_elem718)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_ps_with_auth_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter719 in self.success:
                iter719.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partition_names_ps_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - max_parts
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
        (4, TType.I16, 'max_parts', None, -1, ),  # 4
    )

    def __init__(self, db_name=None, tbl_name=None, part_vals=None, max_parts=thrift_spec[4][4],):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.max_parts = max_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype723, _size720) = iprot.readListBegin()
                    for _i724 in range(_size720):
                        _elem725 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem725)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partition_names_ps_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter726 in self.part_vals:
                oprot.writeString(iter726.encode('utf-8') if sys.version_info[0] == 2 else iter726)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I16, 4)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partition_names_ps_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype730, _size727) = iprot.readListBegin()
                    for _i731 in range(_size727):
                        _elem732 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem732)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partition_names_ps_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter733 in self.success:
                oprot.writeString(iter733.encode('utf-8') if sys.version_info[0] == 2 else iter733)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_by_filter_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - filter
     - max_parts
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'filter', 'UTF8', None, ),  # 3
        (4, TType.I16, 'max_parts', None, -1, ),  # 4
    )

    def __init__(self, db_name=None, tbl_name=None, filter=None, max_parts=thrift_spec[4][4],):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.filter = filter
        self.max_parts = max_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.filter = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I16:
                    self.max_parts = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_by_filter_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRING, 3)
            oprot.writeString(self.filter.encode('utf-8') if sys.version_info[0] == 2 else self.filter)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I16, 4)
            oprot.writeI16(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_by_filter_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (Partition, Partition.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype737, _size734) = iprot.readListBegin()
                    for _i738 in range(_size734):
                        _elem739 = Partition()
                        _elem739.read(iprot)
                        self.success.append(_elem739)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_by_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter740 in self.success:
                iter740.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_part_specs_by_filter_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - filter
     - max_parts
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'filter', 'UTF8', None, ),  # 3
        (4, TType.I32, 'max_parts', None, -1, ),  # 4
    )

    def __init__(self, db_name=None, tbl_name=None, filter=None, max_parts=thrift_spec[4][4],):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.filter = filter
        self.max_parts = max_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.filter = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.max_parts = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_part_specs_by_filter_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.filter is not None:
            oprot.writeFieldBegin('filter', TType.STRING, 3)
            oprot.writeString(self.filter.encode('utf-8') if sys.version_info[0] == 2 else self.filter)
            oprot.writeFieldEnd()
        if self.max_parts is not None:
            oprot.writeFieldBegin('max_parts', TType.I32, 4)
            oprot.writeI32(self.max_parts)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_part_specs_by_filter_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (PartitionSpec, PartitionSpec.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype744, _size741) = iprot.readListBegin()
                    for _i745 in range(_size741):
                        _elem746 = PartitionSpec()
                        _elem746.read(iprot)
                        self.success.append(_elem746)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_part_specs_by_filter_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter747 in self.success:
                iter747.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_by_expr_args(object):
    """
    Attributes:
     - req
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'req', (PartitionsByExprRequest, PartitionsByExprRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, req=None,):
        self.req = req

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.req = PartitionsByExprRequest()
                    self.req.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_by_expr_args')
        if self.req is not None:
            oprot.writeFieldBegin('req', TType.STRUCT, 1)
            self.req.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_by_expr_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (PartitionsByExprResult, PartitionsByExprResult.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PartitionsByExprResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_by_expr_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_by_names_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - names
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.LIST, 'names', (TType.STRING, 'UTF8', False), None, ),  # 3
    )

    def __init__(self, db_name=None, tbl_name=None, names=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.names = names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.names = []
                    (_etype751, _size748) = iprot.readListBegin()
                    for _i752 in range(_size748):
                        _elem753 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.names.append(_elem753)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_by_names_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.names is not None:
            oprot.writeFieldBegin('names', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.names))
            for iter754 in self.names:
                oprot.writeString(iter754.encode('utf-8') if sys.version_info[0] == 2 else iter754)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_by_names_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (Partition, Partition.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype758, _size755) = iprot.readListBegin()
                    for _i759 in range(_size755):
                        _elem760 = Partition()
                        _elem760.read(iprot)
                        self.success.append(_elem760)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_by_names_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter761 in self.success:
                iter761.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_partition_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - new_part
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ),  # 3
    )

    def __init__(self, db_name=None, tbl_name=None, new_part=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.new_part = new_part

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.new_part = Partition()
                    self.new_part.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_partition_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_part is not None:
            oprot.writeFieldBegin('new_part', TType.STRUCT, 3)
            self.new_part.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_partition_result(object):
    """
    Attributes:
     - o1
     - o2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_partition_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_partitions_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - new_parts
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.LIST, 'new_parts', (TType.STRUCT, (Partition, Partition.thrift_spec), False), None, ),  # 3
    )

    def __init__(self, db_name=None, tbl_name=None, new_parts=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.new_parts = new_parts

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.new_parts = []
                    (_etype765, _size762) = iprot.readListBegin()
                    for _i766 in range(_size762):
                        _elem767 = Partition()
                        _elem767.read(iprot)
                        self.new_parts.append(_elem767)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_partitions_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_parts is not None:
            oprot.writeFieldBegin('new_parts', TType.LIST, 3)
            oprot.writeListBegin(TType.STRUCT, len(self.new_parts))
            for iter768 in self.new_parts:
                iter768.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_partitions_result(object):
    """
    Attributes:
     - o1
     - o2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_partitions_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_partition_with_environment_context_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - new_part
     - environment_context
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'environment_context', (EnvironmentContext, EnvironmentContext.thrift_spec), None, ),  # 4
    )

    def __init__(self, db_name=None, tbl_name=None, new_part=None, environment_context=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.new_part = new_part
        self.environment_context = environment_context

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.new_part = Partition()
                    self.new_part.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.environment_context = EnvironmentContext()
                    self.environment_context.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_partition_with_environment_context_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.new_part is not None:
            oprot.writeFieldBegin('new_part', TType.STRUCT, 3)
            self.new_part.write(oprot)
            oprot.writeFieldEnd()
        if self.environment_context is not None:
            oprot.writeFieldBegin('environment_context', TType.STRUCT, 4)
            self.environment_context.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_partition_with_environment_context_result(object):
    """
    Attributes:
     - o1
     - o2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_partition_with_environment_context_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class rename_partition_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - new_part
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 3
        (4, TType.STRUCT, 'new_part', (Partition, Partition.thrift_spec), None, ),  # 4
    )

    def __init__(self, db_name=None, tbl_name=None, part_vals=None, new_part=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.new_part = new_part

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype772, _size769) = iprot.readListBegin()
                    for _i773 in range(_size769):
                        _elem774 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem774)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.new_part = Partition()
                    self.new_part.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('rename_partition_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter775 in self.part_vals:
                oprot.writeString(iter775.encode('utf-8') if sys.version_info[0] == 2 else iter775)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.new_part is not None:
            oprot.writeFieldBegin('new_part', TType.STRUCT, 4)
            self.new_part.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class rename_partition_result(object):
    """
    Attributes:
     - o1
     - o2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('rename_partition_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class partition_name_has_valid_characters_args(object):
    """
    Attributes:
     - part_vals
     - throw_exception
    """

    thrift_spec = (
        None,  # 0
        (1, TType.LIST, 'part_vals', (TType.STRING, 'UTF8', False), None, ),  # 1
        (2, TType.BOOL, 'throw_exception', None, None, ),  # 2
    )

    def __init__(self, part_vals=None, throw_exception=None,):
        self.part_vals = part_vals
        self.throw_exception = throw_exception

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.LIST:
                    self.part_vals = []
                    (_etype779, _size776) = iprot.readListBegin()
                    for _i780 in range(_size776):
                        _elem781 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals.append(_elem781)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.BOOL:
                    self.throw_exception = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('partition_name_has_valid_characters_args')
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.LIST, 1)
            oprot.writeListBegin(TType.STRING, len(self.part_vals))
            for iter782 in self.part_vals:
                oprot.writeString(iter782.encode('utf-8') if sys.version_info[0] == 2 else iter782)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.throw_exception is not None:
            oprot.writeFieldBegin('throw_exception', TType.BOOL, 2)
            oprot.writeBool(self.throw_exception)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class partition_name_has_valid_characters_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('partition_name_has_valid_characters_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_config_value_args(object):
    """
    Attributes:
     - name
     - defaultValue
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'defaultValue', 'UTF8', None, ),  # 2
    )

    def __init__(self, name=None, defaultValue=None,):
        self.name = name
        self.defaultValue = defaultValue

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.defaultValue = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_config_value_args')
        if self.name is not None:
            oprot.writeFieldBegin('name', TType.STRING, 1)
            oprot.writeString(self.name.encode('utf-8') if sys.version_info[0] == 2 else self.name)
            oprot.writeFieldEnd()
        if self.defaultValue is not None:
            oprot.writeFieldBegin('defaultValue', TType.STRING, 2)
            oprot.writeString(self.defaultValue.encode('utf-8') if sys.version_info[0] == 2 else self.defaultValue)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_config_value_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
        (1, TType.STRUCT, 'o1', (ConfigValSecurityException, ConfigValSecurityException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = ConfigValSecurityException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_config_value_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class partition_name_to_vals_args(object):
    """
    Attributes:
     - part_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'part_name', 'UTF8', None, ),  # 1
    )

    def __init__(self, part_name=None,):
        self.part_name = part_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('partition_name_to_vals_args')
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 1)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class partition_name_to_vals_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype786, _size783) = iprot.readListBegin()
                    for _i787 in range(_size783):
                        _elem788 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem788)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('partition_name_to_vals_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter789 in self.success:
                oprot.writeString(iter789.encode('utf-8') if sys.version_info[0] == 2 else iter789)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class partition_name_to_spec_args(object):
    """
    Attributes:
     - part_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'part_name', 'UTF8', None, ),  # 1
    )

    def __init__(self, part_name=None,):
        self.part_name = part_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('partition_name_to_spec_args')
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 1)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class partition_name_to_spec_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.MAP, 'success', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.MAP:
                    self.success = {}
                    (_ktype791, _vtype792, _size790) = iprot.readMapBegin()
                    for _i794 in range(_size790):
                        _key795 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val796 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success[_key795] = _val796
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('partition_name_to_spec_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.MAP, 0)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.success))
            for kiter797, viter798 in self.success.items():
                oprot.writeString(kiter797.encode('utf-8') if sys.version_info[0] == 2 else kiter797)
                oprot.writeString(viter798.encode('utf-8') if sys.version_info[0] == 2 else viter798)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class markPartitionForEvent_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.MAP, 'part_vals', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
        (4, TType.I32, 'eventType', None, None, ),  # 4
    )

    def __init__(self, db_name=None, tbl_name=None, part_vals=None, eventType=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.eventType = eventType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.part_vals = {}
                    (_ktype800, _vtype801, _size799) = iprot.readMapBegin()
                    for _i803 in range(_size799):
                        _key804 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val805 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals[_key804] = _val805
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.eventType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('markPartitionForEvent_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.part_vals))
            for kiter806, viter807 in self.part_vals.items():
                oprot.writeString(kiter806.encode('utf-8') if sys.version_info[0] == 2 else kiter806)
                oprot.writeString(viter807.encode('utf-8') if sys.version_info[0] == 2 else viter807)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.eventType is not None:
            oprot.writeFieldBegin('eventType', TType.I32, 4)
            oprot.writeI32(self.eventType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class markPartitionForEvent_result(object):
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4
     - o5
     - o6
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'o4', (UnknownTableException, UnknownTableException.thrift_spec), None, ),  # 4
        (5, TType.STRUCT, 'o5', (UnknownPartitionException, UnknownPartitionException.thrift_spec), None, ),  # 5
        (6, TType.STRUCT, 'o6', (InvalidPartitionException, InvalidPartitionException.thrift_spec), None, ),  # 6
    )

    def __init__(self, o1=None, o2=None, o3=None, o4=None, o5=None, o6=None,):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4
        self.o5 = o5
        self.o6 = o6

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = UnknownTableException()
                    self.o4.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.o5 = UnknownPartitionException()
                    self.o5.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.o6 = InvalidPartitionException()
                    self.o6.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('markPartitionForEvent_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        if self.o5 is not None:
            oprot.writeFieldBegin('o5', TType.STRUCT, 5)
            self.o5.write(oprot)
            oprot.writeFieldEnd()
        if self.o6 is not None:
            oprot.writeFieldBegin('o6', TType.STRUCT, 6)
            self.o6.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class isPartitionMarkedForEvent_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_vals
     - eventType
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.MAP, 'part_vals', (TType.STRING, 'UTF8', TType.STRING, 'UTF8', False), None, ),  # 3
        (4, TType.I32, 'eventType', None, None, ),  # 4
    )

    def __init__(self, db_name=None, tbl_name=None, part_vals=None, eventType=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_vals = part_vals
        self.eventType = eventType

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.MAP:
                    self.part_vals = {}
                    (_ktype809, _vtype810, _size808) = iprot.readMapBegin()
                    for _i812 in range(_size808):
                        _key813 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        _val814 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.part_vals[_key813] = _val814
                    iprot.readMapEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.I32:
                    self.eventType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('isPartitionMarkedForEvent_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_vals is not None:
            oprot.writeFieldBegin('part_vals', TType.MAP, 3)
            oprot.writeMapBegin(TType.STRING, TType.STRING, len(self.part_vals))
            for kiter815, viter816 in self.part_vals.items():
                oprot.writeString(kiter815.encode('utf-8') if sys.version_info[0] == 2 else kiter815)
                oprot.writeString(viter816.encode('utf-8') if sys.version_info[0] == 2 else viter816)
            oprot.writeMapEnd()
            oprot.writeFieldEnd()
        if self.eventType is not None:
            oprot.writeFieldBegin('eventType', TType.I32, 4)
            oprot.writeI32(self.eventType)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class isPartitionMarkedForEvent_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4
     - o5
     - o6
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (UnknownDBException, UnknownDBException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'o4', (UnknownTableException, UnknownTableException.thrift_spec), None, ),  # 4
        (5, TType.STRUCT, 'o5', (UnknownPartitionException, UnknownPartitionException.thrift_spec), None, ),  # 5
        (6, TType.STRUCT, 'o6', (InvalidPartitionException, InvalidPartitionException.thrift_spec), None, ),  # 6
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None, o5=None, o6=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4
        self.o5 = o5
        self.o6 = o6

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = UnknownDBException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = UnknownTableException()
                    self.o4.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.STRUCT:
                    self.o5 = UnknownPartitionException()
                    self.o5.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.STRUCT:
                    self.o6 = InvalidPartitionException()
                    self.o6.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('isPartitionMarkedForEvent_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        if self.o5 is not None:
            oprot.writeFieldBegin('o5', TType.STRUCT, 5)
            self.o5.write(oprot)
            oprot.writeFieldEnd()
        if self.o6 is not None:
            oprot.writeFieldBegin('o6', TType.STRUCT, 6)
            self.o6.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class add_index_args(object):
    """
    Attributes:
     - new_index
     - index_table
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'new_index', (Index, Index.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'index_table', (Table, Table.thrift_spec), None, ),  # 2
    )

    def __init__(self, new_index=None, index_table=None,):
        self.new_index = new_index
        self.index_table = index_table

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.new_index = Index()
                    self.new_index.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.index_table = Table()
                    self.index_table.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('add_index_args')
        if self.new_index is not None:
            oprot.writeFieldBegin('new_index', TType.STRUCT, 1)
            self.new_index.write(oprot)
            oprot.writeFieldEnd()
        if self.index_table is not None:
            oprot.writeFieldBegin('index_table', TType.STRUCT, 2)
            self.index_table.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class add_index_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Index, Index.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Index()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = AlreadyExistsException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('add_index_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_index_args(object):
    """
    Attributes:
     - dbname
     - base_tbl_name
     - idx_name
     - new_idx
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'dbname', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'base_tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'idx_name', 'UTF8', None, ),  # 3
        (4, TType.STRUCT, 'new_idx', (Index, Index.thrift_spec), None, ),  # 4
    )

    def __init__(self, dbname=None, base_tbl_name=None, idx_name=None, new_idx=None,):
        self.dbname = dbname
        self.base_tbl_name = base_tbl_name
        self.idx_name = idx_name
        self.new_idx = new_idx

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbname = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.base_tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.idx_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.new_idx = Index()
                    self.new_idx.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_index_args')
        if self.dbname is not None:
            oprot.writeFieldBegin('dbname', TType.STRING, 1)
            oprot.writeString(self.dbname.encode('utf-8') if sys.version_info[0] == 2 else self.dbname)
            oprot.writeFieldEnd()
        if self.base_tbl_name is not None:
            oprot.writeFieldBegin('base_tbl_name', TType.STRING, 2)
            oprot.writeString(self.base_tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.base_tbl_name)
            oprot.writeFieldEnd()
        if self.idx_name is not None:
            oprot.writeFieldBegin('idx_name', TType.STRING, 3)
            oprot.writeString(self.idx_name.encode('utf-8') if sys.version_info[0] == 2 else self.idx_name)
            oprot.writeFieldEnd()
        if self.new_idx is not None:
            oprot.writeFieldBegin('new_idx', TType.STRUCT, 4)
            self.new_idx.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_index_result(object):
    """
    Attributes:
     - o1
     - o2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_index_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_index_by_name_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - index_name
     - deleteData
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'index_name', 'UTF8', None, ),  # 3
        (4, TType.BOOL, 'deleteData', None, None, ),  # 4
    )

    def __init__(self, db_name=None, tbl_name=None, index_name=None, deleteData=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.index_name = index_name
        self.deleteData = deleteData

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.index_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.BOOL:
                    self.deleteData = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_index_by_name_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.index_name is not None:
            oprot.writeFieldBegin('index_name', TType.STRING, 3)
            oprot.writeString(self.index_name.encode('utf-8') if sys.version_info[0] == 2 else self.index_name)
            oprot.writeFieldEnd()
        if self.deleteData is not None:
            oprot.writeFieldBegin('deleteData', TType.BOOL, 4)
            oprot.writeBool(self.deleteData)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_index_by_name_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_index_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_index_by_name_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - index_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'index_name', 'UTF8', None, ),  # 3
    )

    def __init__(self, db_name=None, tbl_name=None, index_name=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.index_name = index_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.index_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_index_by_name_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.index_name is not None:
            oprot.writeFieldBegin('index_name', TType.STRING, 3)
            oprot.writeString(self.index_name.encode('utf-8') if sys.version_info[0] == 2 else self.index_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_index_by_name_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Index, Index.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Index()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_index_by_name_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_indexes_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - max_indexes
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.I16, 'max_indexes', None, -1, ),  # 3
    )

    def __init__(self, db_name=None, tbl_name=None, max_indexes=thrift_spec[3][4],):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_indexes = max_indexes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_indexes = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_indexes_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_indexes is not None:
            oprot.writeFieldBegin('max_indexes', TType.I16, 3)
            oprot.writeI16(self.max_indexes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_indexes_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (Index, Index.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype820, _size817) = iprot.readListBegin()
                    for _i821 in range(_size817):
                        _elem822 = Index()
                        _elem822.read(iprot)
                        self.success.append(_elem822)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_indexes_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter823 in self.success:
                iter823.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_index_names_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - max_indexes
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.I16, 'max_indexes', None, -1, ),  # 3
    )

    def __init__(self, db_name=None, tbl_name=None, max_indexes=thrift_spec[3][4],):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.max_indexes = max_indexes

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I16:
                    self.max_indexes = iprot.readI16()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_index_names_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.max_indexes is not None:
            oprot.writeFieldBegin('max_indexes', TType.I16, 3)
            oprot.writeI16(self.max_indexes)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_index_names_result(object):
    """
    Attributes:
     - success
     - o2
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o2=None,):
        self.success = success
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype827, _size824) = iprot.readListBegin()
                    for _i828 in range(_size824):
                        _elem829 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem829)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_index_names_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter830 in self.success:
                oprot.writeString(iter830.encode('utf-8') if sys.version_info[0] == 2 else iter830)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 1)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class update_table_column_statistics_args(object):
    """
    Attributes:
     - stats_obj
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'stats_obj', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ),  # 1
    )

    def __init__(self, stats_obj=None,):
        self.stats_obj = stats_obj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stats_obj = ColumnStatistics()
                    self.stats_obj.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('update_table_column_statistics_args')
        if self.stats_obj is not None:
            oprot.writeFieldBegin('stats_obj', TType.STRUCT, 1)
            self.stats_obj.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class update_table_column_statistics_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ),  # 4
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException()
                    self.o4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('update_table_column_statistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class update_partition_column_statistics_args(object):
    """
    Attributes:
     - stats_obj
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'stats_obj', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ),  # 1
    )

    def __init__(self, stats_obj=None,):
        self.stats_obj = stats_obj

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.stats_obj = ColumnStatistics()
                    self.stats_obj.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('update_partition_column_statistics_args')
        if self.stats_obj is not None:
            oprot.writeFieldBegin('stats_obj', TType.STRUCT, 1)
            self.stats_obj.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class update_partition_column_statistics_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ),  # 4
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException()
                    self.o4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('update_partition_column_statistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_table_column_statistics_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - col_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'col_name', 'UTF8', None, ),  # 3
    )

    def __init__(self, db_name=None, tbl_name=None, col_name=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.col_name = col_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.col_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_table_column_statistics_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.col_name is not None:
            oprot.writeFieldBegin('col_name', TType.STRING, 3)
            oprot.writeString(self.col_name.encode('utf-8') if sys.version_info[0] == 2 else self.col_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_table_column_statistics_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (InvalidInputException, InvalidInputException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'o4', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 4
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ColumnStatistics()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidInputException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidObjectException()
                    self.o4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_table_column_statistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partition_column_statistics_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
     - col_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'part_name', 'UTF8', None, ),  # 3
        (4, TType.STRING, 'col_name', 'UTF8', None, ),  # 4
    )

    def __init__(self, db_name=None, tbl_name=None, part_name=None, col_name=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name
        self.col_name = col_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.col_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partition_column_statistics_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 3)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        if self.col_name is not None:
            oprot.writeFieldBegin('col_name', TType.STRING, 4)
            oprot.writeString(self.col_name.encode('utf-8') if sys.version_info[0] == 2 else self.col_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partition_column_statistics_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ColumnStatistics, ColumnStatistics.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (InvalidInputException, InvalidInputException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'o4', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 4
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ColumnStatistics()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidInputException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidObjectException()
                    self.o4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partition_column_statistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_table_statistics_req_args(object):
    """
    Attributes:
     - request
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'request', (TableStatsRequest, TableStatsRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = TableStatsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_table_statistics_req_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_table_statistics_req_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (TableStatsResult, TableStatsResult.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = TableStatsResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_table_statistics_req_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_statistics_req_args(object):
    """
    Attributes:
     - request
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'request', (PartitionsStatsRequest, PartitionsStatsRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = PartitionsStatsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_statistics_req_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_partitions_statistics_req_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (PartitionsStatsResult, PartitionsStatsResult.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PartitionsStatsResult()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_partitions_statistics_req_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_aggr_stats_for_args(object):
    """
    Attributes:
     - request
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'request', (PartitionsStatsRequest, PartitionsStatsRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = PartitionsStatsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_aggr_stats_for_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_aggr_stats_for_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (AggrStats, AggrStats.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = AggrStats()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_aggr_stats_for_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class set_aggr_stats_for_args(object):
    """
    Attributes:
     - request
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'request', (SetPartitionsStatsRequest, SetPartitionsStatsRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = SetPartitionsStatsRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('set_aggr_stats_for_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class set_aggr_stats_for_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ),  # 4
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException()
                    self.o4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('set_aggr_stats_for_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class delete_partition_column_statistics_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - part_name
     - col_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'part_name', 'UTF8', None, ),  # 3
        (4, TType.STRING, 'col_name', 'UTF8', None, ),  # 4
    )

    def __init__(self, db_name=None, tbl_name=None, part_name=None, col_name=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.part_name = part_name
        self.col_name = col_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.part_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.col_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('delete_partition_column_statistics_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.part_name is not None:
            oprot.writeFieldBegin('part_name', TType.STRING, 3)
            oprot.writeString(self.part_name.encode('utf-8') if sys.version_info[0] == 2 else self.part_name)
            oprot.writeFieldEnd()
        if self.col_name is not None:
            oprot.writeFieldBegin('col_name', TType.STRING, 4)
            oprot.writeString(self.col_name.encode('utf-8') if sys.version_info[0] == 2 else self.col_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class delete_partition_column_statistics_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ),  # 4
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException()
                    self.o4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('delete_partition_column_statistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class delete_table_column_statistics_args(object):
    """
    Attributes:
     - db_name
     - tbl_name
     - col_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'db_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'tbl_name', 'UTF8', None, ),  # 2
        (3, TType.STRING, 'col_name', 'UTF8', None, ),  # 3
    )

    def __init__(self, db_name=None, tbl_name=None, col_name=None,):
        self.db_name = db_name
        self.tbl_name = tbl_name
        self.col_name = col_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.db_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.tbl_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRING:
                    self.col_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('delete_table_column_statistics_args')
        if self.db_name is not None:
            oprot.writeFieldBegin('db_name', TType.STRING, 1)
            oprot.writeString(self.db_name.encode('utf-8') if sys.version_info[0] == 2 else self.db_name)
            oprot.writeFieldEnd()
        if self.tbl_name is not None:
            oprot.writeFieldBegin('tbl_name', TType.STRING, 2)
            oprot.writeString(self.tbl_name.encode('utf-8') if sys.version_info[0] == 2 else self.tbl_name)
            oprot.writeFieldEnd()
        if self.col_name is not None:
            oprot.writeFieldBegin('col_name', TType.STRING, 3)
            oprot.writeString(self.col_name.encode('utf-8') if sys.version_info[0] == 2 else self.col_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class delete_table_column_statistics_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
     - o4
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'o4', (InvalidInputException, InvalidInputException.thrift_spec), None, ),  # 4
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None, o4=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = InvalidObjectException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = InvalidInputException()
                    self.o4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('delete_table_column_statistics_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class create_function_args(object):
    """
    Attributes:
     - func
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'func', (Function, Function.thrift_spec), None, ),  # 1
    )

    def __init__(self, func=None,):
        self.func = func

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.func = Function()
                    self.func.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('create_function_args')
        if self.func is not None:
            oprot.writeFieldBegin('func', TType.STRUCT, 1)
            self.func.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class create_function_result(object):
    """
    Attributes:
     - o1
     - o2
     - o3
     - o4
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (AlreadyExistsException, AlreadyExistsException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (InvalidObjectException, InvalidObjectException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 3
        (4, TType.STRUCT, 'o4', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 4
    )

    def __init__(self, o1=None, o2=None, o3=None, o4=None,):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3
        self.o4 = o4

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = AlreadyExistsException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = InvalidObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRUCT:
                    self.o4 = NoSuchObjectException()
                    self.o4.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('create_function_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        if self.o4 is not None:
            oprot.writeFieldBegin('o4', TType.STRUCT, 4)
            self.o4.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_function_args(object):
    """
    Attributes:
     - dbName
     - funcName
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'funcName', 'UTF8', None, ),  # 2
    )

    def __init__(self, dbName=None, funcName=None,):
        self.dbName = dbName
        self.funcName = funcName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.funcName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_function_args')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.funcName is not None:
            oprot.writeFieldBegin('funcName', TType.STRING, 2)
            oprot.writeString(self.funcName.encode('utf-8') if sys.version_info[0] == 2 else self.funcName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_function_result(object):
    """
    Attributes:
     - o1
     - o3
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o3', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, o1=None, o3=None,):
        self.o1 = o1
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchObjectException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o3 = MetaException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_function_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 2)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_function_args(object):
    """
    Attributes:
     - dbName
     - funcName
     - newFunc
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'funcName', 'UTF8', None, ),  # 2
        (3, TType.STRUCT, 'newFunc', (Function, Function.thrift_spec), None, ),  # 3
    )

    def __init__(self, dbName=None, funcName=None, newFunc=None,):
        self.dbName = dbName
        self.funcName = funcName
        self.newFunc = newFunc

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.funcName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.newFunc = Function()
                    self.newFunc.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_function_args')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.funcName is not None:
            oprot.writeFieldBegin('funcName', TType.STRING, 2)
            oprot.writeString(self.funcName.encode('utf-8') if sys.version_info[0] == 2 else self.funcName)
            oprot.writeFieldEnd()
        if self.newFunc is not None:
            oprot.writeFieldBegin('newFunc', TType.STRUCT, 3)
            self.newFunc.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class alter_function_result(object):
    """
    Attributes:
     - o1
     - o2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (InvalidOperationException, InvalidOperationException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (MetaException, MetaException.thrift_spec), None, ),  # 2
    )

    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = InvalidOperationException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = MetaException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('alter_function_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_functions_args(object):
    """
    Attributes:
     - dbName
     - pattern
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'pattern', 'UTF8', None, ),  # 2
    )

    def __init__(self, dbName=None, pattern=None,):
        self.dbName = dbName
        self.pattern = pattern

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.pattern = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_functions_args')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.pattern is not None:
            oprot.writeFieldBegin('pattern', TType.STRING, 2)
            oprot.writeString(self.pattern.encode('utf-8') if sys.version_info[0] == 2 else self.pattern)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_functions_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype834, _size831) = iprot.readListBegin()
                    for _i835 in range(_size831):
                        _elem836 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem836)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_functions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter837 in self.success:
                oprot.writeString(iter837.encode('utf-8') if sys.version_info[0] == 2 else iter837)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_function_args(object):
    """
    Attributes:
     - dbName
     - funcName
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'dbName', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'funcName', 'UTF8', None, ),  # 2
    )

    def __init__(self, dbName=None, funcName=None,):
        self.dbName = dbName
        self.funcName = funcName

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.dbName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.funcName = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_function_args')
        if self.dbName is not None:
            oprot.writeFieldBegin('dbName', TType.STRING, 1)
            oprot.writeString(self.dbName.encode('utf-8') if sys.version_info[0] == 2 else self.dbName)
            oprot.writeFieldEnd()
        if self.funcName is not None:
            oprot.writeFieldBegin('funcName', TType.STRING, 2)
            oprot.writeString(self.funcName.encode('utf-8') if sys.version_info[0] == 2 else self.funcName)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_function_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (Function, Function.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchObjectException, NoSuchObjectException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = Function()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchObjectException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_function_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_all_functions_args(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_all_functions_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_all_functions_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (GetAllFunctionsResponse, GetAllFunctionsResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetAllFunctionsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_all_functions_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class create_role_args(object):
    """
    Attributes:
     - role
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'role', (Role, Role.thrift_spec), None, ),  # 1
    )

    def __init__(self, role=None,):
        self.role = role

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.role = Role()
                    self.role.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('create_role_args')
        if self.role is not None:
            oprot.writeFieldBegin('role', TType.STRUCT, 1)
            self.role.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class create_role_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('create_role_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_role_args(object):
    """
    Attributes:
     - role_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'role_name', 'UTF8', None, ),  # 1
    )

    def __init__(self, role_name=None,):
        self.role_name = role_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.role_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_role_args')
        if self.role_name is not None:
            oprot.writeFieldBegin('role_name', TType.STRING, 1)
            oprot.writeString(self.role_name.encode('utf-8') if sys.version_info[0] == 2 else self.role_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class drop_role_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('drop_role_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_role_names_args(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_role_names_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_role_names_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype841, _size838) = iprot.readListBegin()
                    for _i842 in range(_size838):
                        _elem843 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem843)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_role_names_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter844 in self.success:
                oprot.writeString(iter844.encode('utf-8') if sys.version_info[0] == 2 else iter844)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class grant_role_args(object):
    """
    Attributes:
     - role_name
     - principal_name
     - principal_type
     - grantor
     - grantorType
     - grant_option
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'role_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'principal_name', 'UTF8', None, ),  # 2
        (3, TType.I32, 'principal_type', None, None, ),  # 3
        (4, TType.STRING, 'grantor', 'UTF8', None, ),  # 4
        (5, TType.I32, 'grantorType', None, None, ),  # 5
        (6, TType.BOOL, 'grant_option', None, None, ),  # 6
    )

    def __init__(self, role_name=None, principal_name=None, principal_type=None, grantor=None, grantorType=None, grant_option=None,):
        self.role_name = role_name
        self.principal_name = principal_name
        self.principal_type = principal_type
        self.grantor = grantor
        self.grantorType = grantorType
        self.grant_option = grant_option

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.role_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.principal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 4:
                if ftype == TType.STRING:
                    self.grantor = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 5:
                if ftype == TType.I32:
                    self.grantorType = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 6:
                if ftype == TType.BOOL:
                    self.grant_option = iprot.readBool()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('grant_role_args')
        if self.role_name is not None:
            oprot.writeFieldBegin('role_name', TType.STRING, 1)
            oprot.writeString(self.role_name.encode('utf-8') if sys.version_info[0] == 2 else self.role_name)
            oprot.writeFieldEnd()
        if self.principal_name is not None:
            oprot.writeFieldBegin('principal_name', TType.STRING, 2)
            oprot.writeString(self.principal_name.encode('utf-8') if sys.version_info[0] == 2 else self.principal_name)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 3)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        if self.grantor is not None:
            oprot.writeFieldBegin('grantor', TType.STRING, 4)
            oprot.writeString(self.grantor.encode('utf-8') if sys.version_info[0] == 2 else self.grantor)
            oprot.writeFieldEnd()
        if self.grantorType is not None:
            oprot.writeFieldBegin('grantorType', TType.I32, 5)
            oprot.writeI32(self.grantorType)
            oprot.writeFieldEnd()
        if self.grant_option is not None:
            oprot.writeFieldBegin('grant_option', TType.BOOL, 6)
            oprot.writeBool(self.grant_option)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class grant_role_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('grant_role_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class revoke_role_args(object):
    """
    Attributes:
     - role_name
     - principal_name
     - principal_type
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'role_name', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'principal_name', 'UTF8', None, ),  # 2
        (3, TType.I32, 'principal_type', None, None, ),  # 3
    )

    def __init__(self, role_name=None, principal_name=None, principal_type=None,):
        self.role_name = role_name
        self.principal_name = principal_name
        self.principal_type = principal_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.role_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.principal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('revoke_role_args')
        if self.role_name is not None:
            oprot.writeFieldBegin('role_name', TType.STRING, 1)
            oprot.writeString(self.role_name.encode('utf-8') if sys.version_info[0] == 2 else self.role_name)
            oprot.writeFieldEnd()
        if self.principal_name is not None:
            oprot.writeFieldBegin('principal_name', TType.STRING, 2)
            oprot.writeString(self.principal_name.encode('utf-8') if sys.version_info[0] == 2 else self.principal_name)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 3)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class revoke_role_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('revoke_role_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class list_roles_args(object):
    """
    Attributes:
     - principal_name
     - principal_type
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'principal_name', 'UTF8', None, ),  # 1
        (2, TType.I32, 'principal_type', None, None, ),  # 2
    )

    def __init__(self, principal_name=None, principal_type=None,):
        self.principal_name = principal_name
        self.principal_type = principal_type

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.principal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('list_roles_args')
        if self.principal_name is not None:
            oprot.writeFieldBegin('principal_name', TType.STRING, 1)
            oprot.writeString(self.principal_name.encode('utf-8') if sys.version_info[0] == 2 else self.principal_name)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 2)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class list_roles_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (Role, Role.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype848, _size845) = iprot.readListBegin()
                    for _i849 in range(_size845):
                        _elem850 = Role()
                        _elem850.read(iprot)
                        self.success.append(_elem850)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('list_roles_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter851 in self.success:
                iter851.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class grant_revoke_role_args(object):
    """
    Attributes:
     - request
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'request', (GrantRevokeRoleRequest, GrantRevokeRoleRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GrantRevokeRoleRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('grant_revoke_role_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class grant_revoke_role_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (GrantRevokeRoleResponse, GrantRevokeRoleResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GrantRevokeRoleResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('grant_revoke_role_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_principals_in_role_args(object):
    """
    Attributes:
     - request
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'request', (GetPrincipalsInRoleRequest, GetPrincipalsInRoleRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GetPrincipalsInRoleRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_principals_in_role_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_principals_in_role_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (GetPrincipalsInRoleResponse, GetPrincipalsInRoleResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetPrincipalsInRoleResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_principals_in_role_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_role_grants_for_principal_args(object):
    """
    Attributes:
     - request
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'request', (GetRoleGrantsForPrincipalRequest, GetRoleGrantsForPrincipalRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GetRoleGrantsForPrincipalRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_role_grants_for_principal_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_role_grants_for_principal_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (GetRoleGrantsForPrincipalResponse, GetRoleGrantsForPrincipalResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetRoleGrantsForPrincipalResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_role_grants_for_principal_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_privilege_set_args(object):
    """
    Attributes:
     - hiveObject
     - user_name
     - group_names
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'hiveObject', (HiveObjectRef, HiveObjectRef.thrift_spec), None, ),  # 1
        (2, TType.STRING, 'user_name', 'UTF8', None, ),  # 2
        (3, TType.LIST, 'group_names', (TType.STRING, 'UTF8', False), None, ),  # 3
    )

    def __init__(self, hiveObject=None, user_name=None, group_names=None,):
        self.hiveObject = hiveObject
        self.user_name = user_name
        self.group_names = group_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.hiveObject = HiveObjectRef()
                    self.hiveObject.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.user_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype855, _size852) = iprot.readListBegin()
                    for _i856 in range(_size852):
                        _elem857 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.group_names.append(_elem857)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_privilege_set_args')
        if self.hiveObject is not None:
            oprot.writeFieldBegin('hiveObject', TType.STRUCT, 1)
            self.hiveObject.write(oprot)
            oprot.writeFieldEnd()
        if self.user_name is not None:
            oprot.writeFieldBegin('user_name', TType.STRING, 2)
            oprot.writeString(self.user_name.encode('utf-8') if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin('group_names', TType.LIST, 3)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter858 in self.group_names:
                oprot.writeString(iter858.encode('utf-8') if sys.version_info[0] == 2 else iter858)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_privilege_set_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (PrincipalPrivilegeSet, PrincipalPrivilegeSet.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = PrincipalPrivilegeSet()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_privilege_set_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class list_privileges_args(object):
    """
    Attributes:
     - principal_name
     - principal_type
     - hiveObject
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'principal_name', 'UTF8', None, ),  # 1
        (2, TType.I32, 'principal_type', None, None, ),  # 2
        (3, TType.STRUCT, 'hiveObject', (HiveObjectRef, HiveObjectRef.thrift_spec), None, ),  # 3
    )

    def __init__(self, principal_name=None, principal_type=None, hiveObject=None,):
        self.principal_name = principal_name
        self.principal_type = principal_type
        self.hiveObject = hiveObject

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.principal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.I32:
                    self.principal_type = iprot.readI32()
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.hiveObject = HiveObjectRef()
                    self.hiveObject.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('list_privileges_args')
        if self.principal_name is not None:
            oprot.writeFieldBegin('principal_name', TType.STRING, 1)
            oprot.writeString(self.principal_name.encode('utf-8') if sys.version_info[0] == 2 else self.principal_name)
            oprot.writeFieldEnd()
        if self.principal_type is not None:
            oprot.writeFieldBegin('principal_type', TType.I32, 2)
            oprot.writeI32(self.principal_type)
            oprot.writeFieldEnd()
        if self.hiveObject is not None:
            oprot.writeFieldBegin('hiveObject', TType.STRUCT, 3)
            self.hiveObject.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class list_privileges_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRUCT, (HiveObjectPrivilege, HiveObjectPrivilege.thrift_spec), False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype862, _size859) = iprot.readListBegin()
                    for _i863 in range(_size859):
                        _elem864 = HiveObjectPrivilege()
                        _elem864.read(iprot)
                        self.success.append(_elem864)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('list_privileges_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRUCT, len(self.success))
            for iter865 in self.success:
                iter865.write(oprot)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class grant_privileges_args(object):
    """
    Attributes:
     - privileges
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'privileges', (PrivilegeBag, PrivilegeBag.thrift_spec), None, ),  # 1
    )

    def __init__(self, privileges=None,):
        self.privileges = privileges

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.privileges = PrivilegeBag()
                    self.privileges.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('grant_privileges_args')
        if self.privileges is not None:
            oprot.writeFieldBegin('privileges', TType.STRUCT, 1)
            self.privileges.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class grant_privileges_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('grant_privileges_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class revoke_privileges_args(object):
    """
    Attributes:
     - privileges
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'privileges', (PrivilegeBag, PrivilegeBag.thrift_spec), None, ),  # 1
    )

    def __init__(self, privileges=None,):
        self.privileges = privileges

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.privileges = PrivilegeBag()
                    self.privileges.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('revoke_privileges_args')
        if self.privileges is not None:
            oprot.writeFieldBegin('privileges', TType.STRUCT, 1)
            self.privileges.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class revoke_privileges_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.BOOL, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.BOOL:
                    self.success = iprot.readBool()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('revoke_privileges_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.BOOL, 0)
            oprot.writeBool(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class grant_revoke_privileges_args(object):
    """
    Attributes:
     - request
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'request', (GrantRevokePrivilegeRequest, GrantRevokePrivilegeRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, request=None,):
        self.request = request

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.request = GrantRevokePrivilegeRequest()
                    self.request.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('grant_revoke_privileges_args')
        if self.request is not None:
            oprot.writeFieldBegin('request', TType.STRUCT, 1)
            self.request.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class grant_revoke_privileges_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (GrantRevokePrivilegeResponse, GrantRevokePrivilegeResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GrantRevokePrivilegeResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('grant_revoke_privileges_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class set_ugi_args(object):
    """
    Attributes:
     - user_name
     - group_names
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'user_name', 'UTF8', None, ),  # 1
        (2, TType.LIST, 'group_names', (TType.STRING, 'UTF8', False), None, ),  # 2
    )

    def __init__(self, user_name=None, group_names=None,):
        self.user_name = user_name
        self.group_names = group_names

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.user_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.LIST:
                    self.group_names = []
                    (_etype869, _size866) = iprot.readListBegin()
                    for _i870 in range(_size866):
                        _elem871 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.group_names.append(_elem871)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('set_ugi_args')
        if self.user_name is not None:
            oprot.writeFieldBegin('user_name', TType.STRING, 1)
            oprot.writeString(self.user_name.encode('utf-8') if sys.version_info[0] == 2 else self.user_name)
            oprot.writeFieldEnd()
        if self.group_names is not None:
            oprot.writeFieldBegin('group_names', TType.LIST, 2)
            oprot.writeListBegin(TType.STRING, len(self.group_names))
            for iter872 in self.group_names:
                oprot.writeString(iter872.encode('utf-8') if sys.version_info[0] == 2 else iter872)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class set_ugi_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.LIST, 'success', (TType.STRING, 'UTF8', False), None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.LIST:
                    self.success = []
                    (_etype876, _size873) = iprot.readListBegin()
                    for _i877 in range(_size873):
                        _elem878 = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                        self.success.append(_elem878)
                    iprot.readListEnd()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('set_ugi_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.LIST, 0)
            oprot.writeListBegin(TType.STRING, len(self.success))
            for iter879 in self.success:
                oprot.writeString(iter879.encode('utf-8') if sys.version_info[0] == 2 else iter879)
            oprot.writeListEnd()
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_delegation_token_args(object):
    """
    Attributes:
     - token_owner
     - renewer_kerberos_principal_name
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'token_owner', 'UTF8', None, ),  # 1
        (2, TType.STRING, 'renewer_kerberos_principal_name', 'UTF8', None, ),  # 2
    )

    def __init__(self, token_owner=None, renewer_kerberos_principal_name=None,):
        self.token_owner = token_owner
        self.renewer_kerberos_principal_name = renewer_kerberos_principal_name

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.token_owner = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRING:
                    self.renewer_kerberos_principal_name = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_delegation_token_args')
        if self.token_owner is not None:
            oprot.writeFieldBegin('token_owner', TType.STRING, 1)
            oprot.writeString(self.token_owner.encode('utf-8') if sys.version_info[0] == 2 else self.token_owner)
            oprot.writeFieldEnd()
        if self.renewer_kerberos_principal_name is not None:
            oprot.writeFieldBegin('renewer_kerberos_principal_name', TType.STRING, 2)
            oprot.writeString(self.renewer_kerberos_principal_name.encode('utf-8') if sys.version_info[0] == 2 else self.renewer_kerberos_principal_name)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_delegation_token_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.STRING, 'success', 'UTF8', None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRING:
                    self.success = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_delegation_token_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRING, 0)
            oprot.writeString(self.success.encode('utf-8') if sys.version_info[0] == 2 else self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class renew_delegation_token_args(object):
    """
    Attributes:
     - token_str_form
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'token_str_form', 'UTF8', None, ),  # 1
    )

    def __init__(self, token_str_form=None,):
        self.token_str_form = token_str_form

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.token_str_form = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('renew_delegation_token_args')
        if self.token_str_form is not None:
            oprot.writeFieldBegin('token_str_form', TType.STRING, 1)
            oprot.writeString(self.token_str_form.encode('utf-8') if sys.version_info[0] == 2 else self.token_str_form)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class renew_delegation_token_result(object):
    """
    Attributes:
     - success
     - o1
    """

    thrift_spec = (
        (0, TType.I64, 'success', None, None, ),  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, success=None, o1=None,):
        self.success = success
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.I64:
                    self.success = iprot.readI64()
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('renew_delegation_token_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.I64, 0)
            oprot.writeI64(self.success)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class cancel_delegation_token_args(object):
    """
    Attributes:
     - token_str_form
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRING, 'token_str_form', 'UTF8', None, ),  # 1
    )

    def __init__(self, token_str_form=None,):
        self.token_str_form = token_str_form

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRING:
                    self.token_str_form = iprot.readString().decode('utf-8') if sys.version_info[0] == 2 else iprot.readString()
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('cancel_delegation_token_args')
        if self.token_str_form is not None:
            oprot.writeFieldBegin('token_str_form', TType.STRING, 1)
            oprot.writeString(self.token_str_form.encode('utf-8') if sys.version_info[0] == 2 else self.token_str_form)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class cancel_delegation_token_result(object):
    """
    Attributes:
     - o1
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (MetaException, MetaException.thrift_spec), None, ),  # 1
    )

    def __init__(self, o1=None,):
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = MetaException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('cancel_delegation_token_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_open_txns_args(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_open_txns_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_open_txns_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (GetOpenTxnsResponse, GetOpenTxnsResponse.thrift_spec), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetOpenTxnsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_open_txns_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_open_txns_info_args(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_open_txns_info_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_open_txns_info_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (GetOpenTxnsInfoResponse, GetOpenTxnsInfoResponse.thrift_spec), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = GetOpenTxnsInfoResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_open_txns_info_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class open_txns_args(object):
    """
    Attributes:
     - rqst
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rqst', (OpenTxnRequest, OpenTxnRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = OpenTxnRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('open_txns_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class open_txns_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (OpenTxnsResponse, OpenTxnsResponse.thrift_spec), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = OpenTxnsResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('open_txns_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class abort_txn_args(object):
    """
    Attributes:
     - rqst
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rqst', (AbortTxnRequest, AbortTxnRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = AbortTxnRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('abort_txn_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class abort_txn_result(object):
    """
    Attributes:
     - o1
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ),  # 1
    )

    def __init__(self, o1=None,):
        self.o1 = o1

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('abort_txn_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class commit_txn_args(object):
    """
    Attributes:
     - rqst
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rqst', (CommitTxnRequest, CommitTxnRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = CommitTxnRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('commit_txn_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class commit_txn_result(object):
    """
    Attributes:
     - o1
     - o2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (TxnAbortedException, TxnAbortedException.thrift_spec), None, ),  # 2
    )

    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = TxnAbortedException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('commit_txn_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class lock_args(object):
    """
    Attributes:
     - rqst
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rqst', (LockRequest, LockRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = LockRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('lock_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class lock_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (LockResponse, LockResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (TxnAbortedException, TxnAbortedException.thrift_spec), None, ),  # 2
    )

    def __init__(self, success=None, o1=None, o2=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LockResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = TxnAbortedException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('lock_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class check_lock_args(object):
    """
    Attributes:
     - rqst
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rqst', (CheckLockRequest, CheckLockRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = CheckLockRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('check_lock_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class check_lock_result(object):
    """
    Attributes:
     - success
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (LockResponse, LockResponse.thrift_spec), None, ),  # 0
        (1, TType.STRUCT, 'o1', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (TxnAbortedException, TxnAbortedException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (NoSuchLockException, NoSuchLockException.thrift_spec), None, ),  # 3
    )

    def __init__(self, success=None, o1=None, o2=None, o3=None,):
        self.success = success
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = LockResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchTxnException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = TxnAbortedException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = NoSuchLockException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('check_lock_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class unlock_args(object):
    """
    Attributes:
     - rqst
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rqst', (UnlockRequest, UnlockRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = UnlockRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('unlock_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class unlock_result(object):
    """
    Attributes:
     - o1
     - o2
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (NoSuchLockException, NoSuchLockException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (TxnOpenException, TxnOpenException.thrift_spec), None, ),  # 2
    )

    def __init__(self, o1=None, o2=None,):
        self.o1 = o1
        self.o2 = o2

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchLockException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = TxnOpenException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('unlock_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class show_locks_args(object):
    """
    Attributes:
     - rqst
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rqst', (ShowLocksRequest, ShowLocksRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = ShowLocksRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('show_locks_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class show_locks_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ShowLocksResponse, ShowLocksResponse.thrift_spec), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ShowLocksResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('show_locks_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class heartbeat_args(object):
    """
    Attributes:
     - ids
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'ids', (HeartbeatRequest, HeartbeatRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, ids=None,):
        self.ids = ids

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.ids = HeartbeatRequest()
                    self.ids.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('heartbeat_args')
        if self.ids is not None:
            oprot.writeFieldBegin('ids', TType.STRUCT, 1)
            self.ids.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class heartbeat_result(object):
    """
    Attributes:
     - o1
     - o2
     - o3
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'o1', (NoSuchLockException, NoSuchLockException.thrift_spec), None, ),  # 1
        (2, TType.STRUCT, 'o2', (NoSuchTxnException, NoSuchTxnException.thrift_spec), None, ),  # 2
        (3, TType.STRUCT, 'o3', (TxnAbortedException, TxnAbortedException.thrift_spec), None, ),  # 3
    )

    def __init__(self, o1=None, o2=None, o3=None,):
        self.o1 = o1
        self.o2 = o2
        self.o3 = o3

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.o1 = NoSuchLockException()
                    self.o1.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 2:
                if ftype == TType.STRUCT:
                    self.o2 = NoSuchTxnException()
                    self.o2.read(iprot)
                else:
                    iprot.skip(ftype)
            elif fid == 3:
                if ftype == TType.STRUCT:
                    self.o3 = TxnAbortedException()
                    self.o3.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('heartbeat_result')
        if self.o1 is not None:
            oprot.writeFieldBegin('o1', TType.STRUCT, 1)
            self.o1.write(oprot)
            oprot.writeFieldEnd()
        if self.o2 is not None:
            oprot.writeFieldBegin('o2', TType.STRUCT, 2)
            self.o2.write(oprot)
            oprot.writeFieldEnd()
        if self.o3 is not None:
            oprot.writeFieldBegin('o3', TType.STRUCT, 3)
            self.o3.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class heartbeat_txn_range_args(object):
    """
    Attributes:
     - txns
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'txns', (HeartbeatTxnRangeRequest, HeartbeatTxnRangeRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, txns=None,):
        self.txns = txns

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.txns = HeartbeatTxnRangeRequest()
                    self.txns.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('heartbeat_txn_range_args')
        if self.txns is not None:
            oprot.writeFieldBegin('txns', TType.STRUCT, 1)
            self.txns.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class heartbeat_txn_range_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (HeartbeatTxnRangeResponse, HeartbeatTxnRangeResponse.thrift_spec), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = HeartbeatTxnRangeResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('heartbeat_txn_range_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class compact_args(object):
    """
    Attributes:
     - rqst
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rqst', (CompactionRequest, CompactionRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = CompactionRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('compact_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class compact_result(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('compact_result')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class show_compact_args(object):
    """
    Attributes:
     - rqst
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rqst', (ShowCompactRequest, ShowCompactRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = ShowCompactRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('show_compact_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class show_compact_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (ShowCompactResponse, ShowCompactResponse.thrift_spec), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = ShowCompactResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('show_compact_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_next_notification_args(object):
    """
    Attributes:
     - rqst
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rqst', (NotificationEventRequest, NotificationEventRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = NotificationEventRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_next_notification_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_next_notification_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (NotificationEventResponse, NotificationEventResponse.thrift_spec), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = NotificationEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_next_notification_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_current_notificationEventId_args(object):

    thrift_spec = (
    )

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_current_notificationEventId_args')
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class get_current_notificationEventId_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (CurrentNotificationEventId, CurrentNotificationEventId.thrift_spec), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = CurrentNotificationEventId()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('get_current_notificationEventId_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class fire_listener_event_args(object):
    """
    Attributes:
     - rqst
    """

    thrift_spec = (
        None,  # 0
        (1, TType.STRUCT, 'rqst', (FireEventRequest, FireEventRequest.thrift_spec), None, ),  # 1
    )

    def __init__(self, rqst=None,):
        self.rqst = rqst

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 1:
                if ftype == TType.STRUCT:
                    self.rqst = FireEventRequest()
                    self.rqst.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('fire_listener_event_args')
        if self.rqst is not None:
            oprot.writeFieldBegin('rqst', TType.STRUCT, 1)
            self.rqst.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)


class fire_listener_event_result(object):
    """
    Attributes:
     - success
    """

    thrift_spec = (
        (0, TType.STRUCT, 'success', (FireEventResponse, FireEventResponse.thrift_spec), None, ),  # 0
    )

    def __init__(self, success=None,):
        self.success = success

    def read(self, iprot):
        if iprot._fast_decode is not None and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None:
            iprot._fast_decode(self, iprot, (self.__class__, self.thrift_spec))
            return
        iprot.readStructBegin()
        while True:
            (fname, ftype, fid) = iprot.readFieldBegin()
            if ftype == TType.STOP:
                break
            if fid == 0:
                if ftype == TType.STRUCT:
                    self.success = FireEventResponse()
                    self.success.read(iprot)
                else:
                    iprot.skip(ftype)
            else:
                iprot.skip(ftype)
            iprot.readFieldEnd()
        iprot.readStructEnd()

    def write(self, oprot):
        if oprot._fast_encode is not None and self.thrift_spec is not None:
            oprot.trans.write(oprot._fast_encode(self, (self.__class__, self.thrift_spec)))
            return
        oprot.writeStructBegin('fire_listener_event_result')
        if self.success is not None:
            oprot.writeFieldBegin('success', TType.STRUCT, 0)
            self.success.write(oprot)
            oprot.writeFieldEnd()
        oprot.writeFieldStop()
        oprot.writeStructEnd()

    def validate(self):
        return

    def __repr__(self):
        L = ['%s=%r' % (key, value)
             for key, value in self.__dict__.items()]
        return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

    def __eq__(self, other):
        return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

    def __ne__(self, other):
        return not (self == other)
